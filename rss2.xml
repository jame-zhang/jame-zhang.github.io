<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jame-Zhang的博客</title>
    <link>https://blog.jame-zhang.top/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>迷茫中的研究僧</description>
    <pubDate>Mon, 05 Nov 2018 11:56:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>ios启动盘制作</title>
      <link>https://blog.jame-zhang.top/2018/11/05/macos%20ios%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C/</link>
      <guid>https://blog.jame-zhang.top/2018/11/05/macos%20ios%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C/</guid>
      <pubDate>Mon, 05 Nov 2018 11:41:42 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="macOS启动盘制作"><a href="#macOS启动盘制作" class="headerlink" title="macOS启动盘制作"></a>macOS启动盘制作</h2><p>从官方或者网上下载了<code>安装 macOS Mojave.dmg</code>之后，将<code>安装 macOS Mojave.app</code>拷贝出来，然后将下面的命令保存为文件，chmod u+x 文件名，然后运行一下，就可以创建ios文件了，直接用于Parallels的安装。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">hdiutil attach <span class="string">"/Users/Jame/Desktop/1/macOS.app/Contents/SharedSupport/InstallESD.dmg"</span> -noverify -nobrowse -mountpoint /Volumes/esd</span><br><span class="line">hdiutil create -o macOS_HighSierra_10.<span class="number">13.0</span><span class="selector-class">.cdr</span> -size <span class="number">6144</span>m -layout SPUD -fs HFS+J</span><br><span class="line">hdiutil attach macOS_HighSierra_10.<span class="number">13.0</span><span class="selector-class">.cdr</span><span class="selector-class">.dmg</span> -noverify -nobrowse -mountpoint /Volumes/iso</span><br><span class="line">asr restore -source <span class="string">"/Users/Jame/Desktop/1/macOS.app/Contents/SharedSupport/BaseSystem.dmg"</span> -target /Volumes/iso -noprompt -noverify -erase</span><br><span class="line">rm /Volumes/OS\ X\ Base\ System/System/Installation/Packages</span><br><span class="line">cp -rp /Volumes/esd/Packages /Volumes/OS\ X\ Base\ System/System/Installation</span><br><span class="line">cp -rp /Volumes/esd/BaseSystem<span class="selector-class">.chunklist</span> /Volumes/OS\ X\ Base\ System/</span><br><span class="line">cp -rp /Volumes/esd/BaseSystem<span class="selector-class">.dmg</span> /Volumes/OS\ X\ Base\ System/</span><br><span class="line">hdiutil detach /Volumes/esd</span><br><span class="line">hdiutil detach /Volumes/OS\ X\ Base\ System</span><br><span class="line">hdiutil convert macOS_HighSierra_10.<span class="number">13.0</span><span class="selector-class">.cdr</span><span class="selector-class">.dmg</span> -format UDTO -o macOS_HighSierra_10.<span class="number">13.0</span>.iso</span><br><span class="line">rm macOS_HighSierra_10.<span class="number">13.0</span><span class="selector-class">.cdr</span><span class="selector-class">.dmg</span></span><br><span class="line">mv macOS_HighSierra_10.<span class="number">13.0</span><span class="selector-class">.iso</span><span class="selector-class">.cdr</span> macOS_HighSierra_10.<span class="number">13.0</span>.iso</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/11/05/macos%20ios%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%B6%E4%BD%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>python笔记</title>
      <link>https://blog.jame-zhang.top/2018/07/13/python%E7%AC%94%E8%AE%B0/</link>
      <guid>https://blog.jame-zhang.top/2018/07/13/python%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Fri, 13 Jul 2018 03:17:05 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;python学习笔记，方便查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不同python版本兼容&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用&lt;a href=&quot;http://six.readthedocs.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;six&lt;/a&gt;模块，如cpickle模块，python3中合并为pickle，导入包&lt;code&gt;from six.moves import cpickle as pickle&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;获取python版本&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;platform&lt;/code&gt;包，版本为：platform.python_version_tuple()&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>python学习笔记，方便查找</p></blockquote><ul><li><strong>不同python版本兼容</strong></li></ul><blockquote><p>使用<a href="http://six.readthedocs.io/" target="_blank" rel="noopener">six</a>模块，如cpickle模块，python3中合并为pickle，导入包<code>from six.moves import cpickle as pickle</code></p></blockquote><ul><li><strong>获取python版本</strong></li></ul><blockquote><p>使用<code>platform</code>包，版本为：platform.python_version_tuple()</p></blockquote><a id="more"></a><ul><li><strong>获取文件名</strong></li></ul><blockquote><p>os.path.basename(sys.argv[0])，返回路径拆分的tail名称，如：/home/temp/temp.py, 获得的是temp.py<br>os.path.dirname()，得到前面的路径</p></blockquote><ul><li><strong>logging的用法</strong></li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os.<span class="built_in">path</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    program = os.<span class="built_in">path</span>.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">    logger = logging.getLogger(program)</span><br><span class="line">    logging.basicConfig(format=<span class="string">'%(asctime)s: %(levelname)s: %(message)s'</span>)</span><br><span class="line">    logging.root.setLevel(level=logging.INFO)</span><br><span class="line">    logger.info(<span class="string">"running %s"</span> % <span class="string">' '</span>.join(sys.argv))</span><br><span class="line"></span><br><span class="line"> logger.info(<span class="string">"use info to print info"</span>)</span><br></pre></td></tr></table></figure><ul><li><p><strong>print函数不换行</strong></p><blockquote><p>print函数不换行， end=’’”</p></blockquote></li><li><p><strong>map函数</strong></p><blockquote><p>map函数进行映射，map(str,a)将a里面的元素转化为str类型</p></blockquote></li><li><p><strong>list.copy为浅拷贝</strong></p><blockquote><p> list.copy为浅拷贝，list.copy() – Return a shallow copy of the list. Equivalent to a[:].</p></blockquote></li></ul><ul><li><p><strong>number包</strong></p><blockquote><p>numbers包为数字包，判断一个变量是否为整数，isinstance(o, numbers.Intergral)，是否为数字isinstance(o, numbers.Number)</p></blockquote></li><li><p><strong>isinstance</strong></p><blockquote><p>isinstance判断一个对象是否为某个类型，与type()不同的是，isinstance考虑了类的继承关系</p></blockquote></li><li><p><strong>str()与repr(）的区别</strong></p><blockquote><p>str是转化为人类可读，repr是转化为机器可读的字符串类型</p></blockquote></li><li><p><strong>下划线开头</strong></p><blockquote><p>函数前单下划线表示私有</p></blockquote></li><li><p><strong>字典get用法</strong></p></li><li><blockquote><p>dictionary.get(“key”, N)，有key则返回key对应的value否者返回N</p></blockquote></li><li><p><strong>字典排序</strong></p><blockquote><p>对字典进行排序，sorted函数，根据value进行排序sotred(dict, key= lambda x:dict[x], reverse=True)<br>使用collections.OrderedDict(dic.items())</p></blockquote></li><li><strong>字典修改</strong><blockquote><p>{}.fromkeys(key, value)，key和value可以使值或者列表，列表快速构建词典</p></blockquote></li></ul><ul><li><strong>拼接变量与字符串</strong><blockquote><p><code>&#39;data_batch_%d&#39; % num</code> 或 <code>&#39;data_batch_{}&#39;.format(b)</code><br><code>print(&#39;hello %(first)s and %(second)s&#39; % {&#39;first&#39;: &#39;df&#39;, &#39;second&#39;: &#39;another df&#39;})</code></p></blockquote></li></ul><ul><li><p><strong>去除html标签</strong></p><blockquote><p>bs4包的BeautifulSoup, bs4.BeautifulSoup(text, ‘html.parser’).get_text()</p></blockquote></li><li><p><strong>正则表达式替换</strong></p><blockquote><p>text = re.sub(r’[^a-zA-Z]’, ‘ ‘, raw_text)，非字母全部替换</p></blockquote></li><li><p><strong>报错提示</strong></p><blockquote><p>raise ValueError(‘text’)</p></blockquote></li><li><p><strong>查看python.exe在哪里</strong></p><blockquote><p>sys.executable</p></blockquote></li><li><p><strong>判断实例</strong></p><blockquote><p>assert isinstance(output_size, (int, tuple))</p></blockquote></li><li><p><strong>查找python解释器路径</strong></p><blockquote><p>import sys<br>print(sys.executable)</p></blockquote></li><li><p><strong>批量安装依赖</strong></p><blockquote><p>pip install -r requirement.txt<br>requirement.txt中一行一个包和版本号,<code>Cython==0.23.4</code></p></blockquote></li><li><p><strong>转化为二进制</strong></p><blockquote><p>bin(x)<br>{0:b}.format(x)</p></blockquote></li><li><p><strong>*args和\</strong>kwargs的作用**</p><blockquote><p>*args表示的是传递不定数量的参数，而**kwargs表示的是keyword arguments，表示的是不定数量的a=1这样的关键字的参数。<a href="https://python.freelycode.com/contribution/detail/427" target="_blank" rel="noopener">例子</a></p></blockquote></li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/07/13/python%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>anaconda 批量安装环境包</title>
      <link>https://blog.jame-zhang.top/2018/07/06/anaconda-%E6%89%B9%E9%87%8F%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E5%8C%85/</link>
      <guid>https://blog.jame-zhang.top/2018/07/06/anaconda-%E6%89%B9%E9%87%8F%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E5%8C%85/</guid>
      <pubDate>Fri, 06 Jul 2018 07:19:28 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="pip安装批量的环境包"><a href="#pip安装批量的环境包" class="headerlink" title="pip安装批量的环境包"></a>pip安装批量的环境包</h2><p>首先依赖环境文件如下，<code>requirements.txt</code>,内容如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cython</span>==0.23.4</span><br><span class="line"><span class="attribute">Jinja2</span>==2.8</span><br><span class="line"><span class="attribute">MarkupSafe</span>==0.23</span><br><span class="line"><span class="attribute">Pillow</span>==3.0.0</span><br><span class="line"><span class="attribute">Pygments</span>==2.0.2</span><br><span class="line"><span class="attribute">appnope</span>==0.1.0</span><br><span class="line"><span class="attribute">argparse</span>==1.2.1</span><br><span class="line"><span class="attribute">backports-abc</span>==0.4</span><br><span class="line">backports.<span class="attribute">ssl-match-hostname</span>==3.5.0.1</span><br><span class="line"><span class="attribute">certifi</span>==2015.11.20.1</span><br><span class="line"><span class="attribute">cycler</span>==0.10.0</span><br><span class="line"><span class="attribute">decorator</span>==4.0.6</span><br><span class="line"><span class="attribute">future</span>==0.16.0</span><br><span class="line"><span class="attribute">gnureadline</span>==6.3.3</span><br><span class="line"><span class="attribute">ipykernel</span>==4.2.2</span><br><span class="line"><span class="attribute">ipython</span>==4.0.1</span><br><span class="line"><span class="attribute">ipython-genutils</span>==0.1.0</span><br><span class="line"><span class="attribute">ipywidgets</span>==4.1.1</span><br><span class="line"><span class="attribute">jsonschema</span>==2.5.1</span><br><span class="line"><span class="attribute">jupyter</span>==1.0.0</span><br><span class="line"><span class="attribute">jupyter-client</span>==4.1.1</span><br><span class="line"><span class="attribute">jupyter-console</span>==4.0.3</span><br><span class="line"><span class="attribute">jupyter-core</span>==4.0.6</span><br><span class="line"><span class="attribute">matplotlib</span>==2.0.0</span><br><span class="line"><span class="attribute">mistune</span>==0.7.1</span><br><span class="line"><span class="attribute">nbconvert</span>==4.1.0</span><br><span class="line"><span class="attribute">nbformat</span>==4.0.1</span><br><span class="line"><span class="attribute">notebook</span>==4.0.6</span><br><span class="line"><span class="attribute">numpy</span>==1.10.4</span><br><span class="line">path.<span class="attribute">py</span>==8.1.2</span><br><span class="line"><span class="attribute">pexpect</span>==4.0.1</span><br><span class="line"><span class="attribute">pickleshare</span>==0.5</span><br><span class="line"><span class="attribute">ptyprocess</span>==0.5</span><br><span class="line"><span class="attribute">pyparsing</span>==2.0.7</span><br><span class="line"><span class="attribute">python-dateutil</span>==2.4.2</span><br><span class="line"><span class="attribute">pytz</span>==2015.7</span><br><span class="line"><span class="attribute">pyzmq</span>==15.1.0</span><br><span class="line"><span class="attribute">qtconsole</span>==4.1.1</span><br><span class="line"><span class="attribute">scipy</span>==0.16.1</span><br><span class="line"><span class="attribute">simplegeneric</span>==0.8.1</span><br><span class="line"><span class="attribute">singledispatch</span>==3.4.0.3</span><br><span class="line"><span class="attribute">sites</span>==0.0.1</span><br><span class="line"><span class="attribute">six</span>==1.10.0</span><br><span class="line"><span class="attribute">terminado</span>==0.5</span><br><span class="line"><span class="attribute">tornado</span>==4.3</span><br><span class="line"><span class="attribute">traitlets</span>==4.0.0</span><br></pre></td></tr></table></figure><p>运行命令：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> -r requirements.txt</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/07/06/anaconda-%E6%89%B9%E9%87%8F%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E5%8C%85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vim</title>
      <link>https://blog.jame-zhang.top/2018/07/02/vim/</link>
      <guid>https://blog.jame-zhang.top/2018/07/02/vim/</guid>
      <pubDate>Mon, 02 Jul 2018 08:03:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;/assets/vim/vim.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;强大的编辑器VIM&quot;&gt;&lt;a href=&quot;#强大的编辑器VIM&quot; class=&quot;headerlink&quot; title=&quot;强大的编辑器VIM&quot;&gt;&lt;/a&gt;强大的编辑器VIM&lt;/h1&gt;&lt;p&gt;学linux的时候肯定会接触到vi和vim，只是可能有很多人（比如我）会选择性的丢弃一些东西，看到实验室对面的大佬用VIM编辑器写代码，效率不要太快，所以呀，该学的还是得学的，之前丢了现在只能补回来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直接看参考连接，这个文档只是为了记录学习过程，并不是为了整理学习教程，所以文档是符合我自己的习惯的，如果想学VIM直接看参考链接即可&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/assets/vim/vim.png" alt=""></p><h1 id="强大的编辑器VIM"><a href="#强大的编辑器VIM" class="headerlink" title="强大的编辑器VIM"></a>强大的编辑器VIM</h1><p>学linux的时候肯定会接触到vi和vim，只是可能有很多人（比如我）会选择性的丢弃一些东西，看到实验室对面的大佬用VIM编辑器写代码，效率不要太快，所以呀，该学的还是得学的，之前丢了现在只能补回来。</p><blockquote><p>直接看参考连接，这个文档只是为了记录学习过程，并不是为了整理学习教程，所以文档是符合我自己的习惯的，如果想学VIM直接看参考链接即可</p></blockquote><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h4 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a>常用模式</h4><ul><li>插入模式(insert)：<code>i</code>进入插入即编辑模式</li><li>命令模式(normal)</li><li>ESE: 回到命令模式</li></ul><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><ul><li>h: 向左移动一个字符</li><li>j: 向下移动</li><li>k: 向上移动</li><li>l: 向右移动</li></ul><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><ul><li>u: 撤销修改</li><li>U: 撤销一整行的修改</li><li>i: 进入编辑模式，在当前光标前插入</li><li>I: 进入编辑模式，在行首插入</li><li>a: 进入编辑模式，在当前光标后插入</li><li>A: 进入编辑模式，在当前行行末插入</li><li>x: 删除光标处所在字符<ul><li>xD: 删除光标处所在字符到行末的内容</li><li>X: 删除光标前的字符 </li></ul></li><li>:help <command>: 显示命令帮助</li><li>w/W: 跳转到下一个单词的第一个字符</li><li>b/B: 跳转到上一个单词第一个字符</li><li>e/E: 跳转到单词的最后一个字符，或者下一个单词的最后一个字符<ul><li>2e: 跳到下一个单词的末尾</li><li>如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成</li><li>如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。</li></ul></li><li><number>w/W(b/B,e/E, h(j,k,l)等操作): <number>代表数字，指定w/W(b/B,e/E等操作)进行操作的次数<ul><li>比如：插入30个’-‘，命令为<code>30i-</code>，然后esc，注意esc不退出的话，并不会完成30次的操作</li></ul></number></number></li><li>f/F<char>: 查找字母，f向右查找，F向右查找</char></li><li>tx：和上面的命令类似，但是是移动到 x 的左边一个位置。（这真的很有用）</li><li>0:　跳得到行首</li><li>$: 跳到行末</li><li>^: 跳到本行第一个不是blank的字符的位置(所谓blank字符就是空格，tab，换行，回车等）)</li><li><em>/#: 查找光标下的字母，\</em>向后查找，#向前查找</li><li>gg: 跳到文件头</li><li>G: 跳到最后一行的行首<ul><li><number>G: 跳到第<number>行</number></number></li></ul></li><li>/<text>: 查找<text>文本，n跳到下一个，N跳到上一个</text></text></li><li>o/O: 插入新行，o在当前行后面插入一行，O在当前行前插入一行</li><li>r: 替换光标处的字符</li><li><strong>R</strong>: 进入替换模式</li><li><p>d: 删除，可与其他键合用，如: dw,d3G(光标所在处到第三行都删除)</p><ul><li><strong>dd</strong>: 删除当前行，同时复制到剪切板</li><li>3dd: 删除三行</li><li><strong>dw</strong>: 删除当前单词</li><li><strong>d$/D</strong>: 删除光标所在处至行末</li><li><strong>p</strong>: 光标前粘贴剪切板的内容 </li><li><strong>P</strong>: 光标后粘贴剪切板的内容 </li><li><strong>cw</strong>: 更改单词</li><li><strong>c$/C</strong>: 更改至行末</li></ul></li><li><p>v: visiual模式，有显示模式</p></li><li>% : 匹配括号移动，包括 (, {, [. （陈皓注：你需要把光标先移到括号上）</li><li>* 和 #:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</li><li>0y$: <ul><li>0 → 先到行头</li><li>y → 从这里开始拷贝</li><li>$ → 拷贝到本行最后一个字符 </li><li>你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。</li><li>你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。</li></ul></li><li>还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：<ul><li>d (删除 )</li><li>v (可视化的选择)<ul><li>vw: 可视化模式下选择单词 </li><li>vwd or vwx: 可视化模式下选择下一单词第一个字符，然后删除选中部分</li></ul></li><li>gU (变大写)</li><li>gu (变小写)</li></ul></li><li>t, → 到逗号前的第一个字符。逗号可以变成其它字符。</li><li>3fa → 在当前行查找第三个出现的a。</li><li>F 和 T → 和 f 和 t 一样，只不过是相反方向。</li><li>还有一个很有用的命令是 dt” → 删除所有的内容，直到遇到双引号—— “。</li><li>ctrl+o: 跳转到上一位置(往前跳)</li><li>ctrl+i: 跳转到下一位置(往回跳)</li><li>%: 跳到括号</li><li><code>:%s/bad/good</code>: 当前行用good替换bad</li><li><code>:%s/hi/bye/g</code>: 整个文件中，用bye替换hi</li><li><code>:%s/x/y/gc</code>: 整个文件中，用y替换x，同时提示</li><li><code>:!ls</code> : 运行ls shell命令</li><li><code>:w play.rb</code>: 保存到play.rb文件</li><li><code>:r play.rb</code>: 打开play.rb文件</li><li><code>:e sun.rb</code>: 重新编辑sun.rb文件，当外部文件改变时，进行重新加载</li><li><code>:help &lt;command&gt;</code>:  查看<command>的帮助文档</li></ul><p><strong>注：</strong>文末有两个参考链接，如果掌握了基本按键后，就可以通过最后两个链接进行训练和熟悉</p><p>参考：<br><a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">简明 VIM 练级攻略</a><br><a href="http://www.openvim.com/" target="_blank" rel="noopener">interactive vim</a><br><a href="http://www.vimgenius.com/lessons/vim-intro/levels/level-1" target="_blank" rel="noopener">vim tutorial</a></p>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/07/02/vim/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何下载直播视频</title>
      <link>https://blog.jame-zhang.top/2018/06/26/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E7%9B%B4%E6%92%AD%E8%A7%86%E9%A2%91/</link>
      <guid>https://blog.jame-zhang.top/2018/06/26/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E7%9B%B4%E6%92%AD%E8%A7%86%E9%A2%91/</guid>
      <pubDate>Tue, 26 Jun 2018 14:44:47 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>emmmm，要下载微博直播的回放视频，搜索了几个，最后找到了方法</p></blockquote><h1 id="mac下"><a href="#mac下" class="headerlink" title="mac下"></a>mac下</h1><ul><li>利用chrome的插件<code>扩展程序Chrono下载管理器</code>，嗅探到m3u8文件</li><li>利用ffmpeg工具，下载并保存为mp4格式的视频<br><code>ffmpeg -i http://.../playlist.m3u8 -c copy -bsf:a aac_adtstoasc output.mp4</code></li></ul><h5 id="TODO-后面再补详细视频"><a href="#TODO-后面再补详细视频" class="headerlink" title="TODO:后面再补详细视频"></a>TODO:后面再补详细视频</h5><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/32528595/ffmpeg-mp4-from-http-live-streaming-m3u8-file" target="_blank" rel="noopener">stackoverflow</a></li><li><a href="http://zhuanlan.51cto.com/art/201711/558658.htm" target="_blank" rel="noopener">51cto</a></li><li><a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">you-get</a></li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/06/26/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E7%9B%B4%E6%92%AD%E8%A7%86%E9%A2%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>腾讯广告算法大赛总结</title>
      <link>https://blog.jame-zhang.top/2018/06/14/%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B%E6%80%BB%E7%BB%93/</link>
      <guid>https://blog.jame-zhang.top/2018/06/14/%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Thu, 14 Jun 2018 00:26:35 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;一转眼两个月过去了，真的是过得毫无察觉，这两个月其实被同学拉着一起参加了&lt;a href=&quot;http://algo.qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;腾讯广告算法大赛&lt;/a&gt;，第一次打比赛，初赛47名，决赛，emmmm，没好好参加，最后都没提交结果，根本来不及跑特征，跑一个模型，基本1天+，最开始的时候根本没机器跑，所以基本就是停滞不前，后面用腾讯云代金券开了96G内存的服务器，可以跑数据，后面又租了一台GPU服务器，内存200G，但是最后只有一周的时间，两天服务器分别跑DNN和LGB，但是跑模型实在太慢，10000迭代的模型太慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;比赛概括&quot;&gt;&lt;a href=&quot;#比赛概括&quot; class=&quot;headerlink&quot; title=&quot;比赛概括&quot;&gt;&lt;/a&gt;比赛概括&lt;/h1&gt;&lt;p&gt;　　比赛官网：&lt;a href=&quot;http://algo.qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://algo.qq.com&lt;/a&gt;，腾讯举办的第二届比赛，我是第一次参加大数据类型的比赛。&lt;br&gt;　　比赛总共分为&lt;strong&gt;3个阶段&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初赛：4月18号 12:00 - 5月23号 11:59:59 &lt;ul&gt;
&lt;li&gt;A阶段：4月18号 12:00 - 5月19号 11:59:59&lt;/li&gt;
&lt;li&gt;B阶段：5月19号 12:00 - 5月23号 11:59:59&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复赛：5月24号 12:00 - 6月13号 11:59:59&lt;ul&gt;
&lt;li&gt;A阶段：5月24号 12:00 - 6月9号 11:59:59&lt;/li&gt;
&lt;li&gt;B阶段：6月9号 12:00 - 6月13号 11:59:59&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;初赛的成绩主要以B阶段提交的最好成绩作为最后成绩，初赛前50有证书+礼品，复赛前20有奖项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一名：30万+证书&lt;/li&gt;
&lt;li&gt;第二名：10万+证书&lt;/li&gt;
&lt;li&gt;第三名：5万+证书&lt;/li&gt;
&lt;li&gt;第4到第10名：1万+证书&lt;/li&gt;
&lt;li&gt;第11到20名：校招免笔试绿卡+礼品&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/algo/prize.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;　　不得不说，腾讯还是很大气，在比赛方面，工作人员各方面的工作都做的比较到位，而且人也很好。关于比赛的详细情况，可移步&lt;a href=&quot;http://algo.qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>一转眼两个月过去了，真的是过得毫无察觉，这两个月其实被同学拉着一起参加了<a href="http://algo.qq.com" target="_blank" rel="noopener">腾讯广告算法大赛</a>，第一次打比赛，初赛47名，决赛，emmmm，没好好参加，最后都没提交结果，根本来不及跑特征，跑一个模型，基本1天+，最开始的时候根本没机器跑，所以基本就是停滞不前，后面用腾讯云代金券开了96G内存的服务器，可以跑数据，后面又租了一台GPU服务器，内存200G，但是最后只有一周的时间，两天服务器分别跑DNN和LGB，但是跑模型实在太慢，10000迭代的模型太慢。</p></blockquote><h1 id="比赛概括"><a href="#比赛概括" class="headerlink" title="比赛概括"></a>比赛概括</h1><p>　　比赛官网：<a href="http://algo.qq.com" target="_blank" rel="noopener">http://algo.qq.com</a>，腾讯举办的第二届比赛，我是第一次参加大数据类型的比赛。<br>　　比赛总共分为<strong>3个阶段</strong>：</p><ul><li>初赛：4月18号 12:00 - 5月23号 11:59:59 <ul><li>A阶段：4月18号 12:00 - 5月19号 11:59:59</li><li>B阶段：5月19号 12:00 - 5月23号 11:59:59</li></ul></li><li>复赛：5月24号 12:00 - 6月13号 11:59:59<ul><li>A阶段：5月24号 12:00 - 6月9号 11:59:59</li><li>B阶段：6月9号 12:00 - 6月13号 11:59:59</li></ul></li></ul><p>初赛的成绩主要以B阶段提交的最好成绩作为最后成绩，初赛前50有证书+礼品，复赛前20有奖项：</p><ul><li>第一名：30万+证书</li><li>第二名：10万+证书</li><li>第三名：5万+证书</li><li>第4到第10名：1万+证书</li><li>第11到20名：校招免笔试绿卡+礼品</li></ul><p><img src="/assets/algo/prize.png" alt=""></p><p>　　不得不说，腾讯还是很大气，在比赛方面，工作人员各方面的工作都做的比较到位，而且人也很好。关于比赛的详细情况，可移步<a href="http://algo.qq.com" target="_blank" rel="noopener">官网</a></p><a id="more"></a><h1 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h1><p>　　这次比赛实际上是一个CTR(Click through rate)，广告点击率问题，即给你用户和广告信息，然后预测用户是否会点击所投放的广告，初赛数据与复赛数据一致，包含四张数据表格：</p><ul><li><strong>train.csv</strong>：训练数据表，字段包含：aid，uid，label，aid为具体广告ID，uid为用户具体ID，ID与用户或者广告一一对应，label取值为1或者-1，分别表示相关与不相关，相关意味着用户会点击广告；</li><li><strong>adFeature</strong>：广告属性数据表，字段包含：aid，advertiserId，campaignId，createId等（由于字段过多，不进行一一复述，详细请查阅<a href="/assets/algo/2018腾讯算法大赛参赛手册-V4.pdf">参赛手册</a>，官网信息可能会更新，所以手册已经下载保存在自己的服务器上。</li><li><strong>userFeature</strong>：用户属性数据表，字段包括：uid，age，LBS，gender等</li><li><strong>test.csv</strong>：测试数据集，字段包括：aid，uid，需要预测给定的aid与uid之间的相关性，给出概率</li></ul><p>　　评估方法采用AUC标准，AUC主要用在分类器评判上，对于正负样本不均匀不敏感<br>此次比赛，正负样本比率：1:19，数据处理上，主要用的是lightgbm，fm，ffm，deepfmm，没有针对不均匀样本进行特殊处理。<br><strong>补充：</strong>详见<a href="https://www.zhihu.com/question/39840928/answer/83576302" target="_blank" rel="noopener">知乎</a></p><ul><li>AUC（Area under curve）：ROC曲线下的面积，含义为一个二分类器下任取样本正负样本各一个，分类器将正样本判断为正的概率P1，负样本为P0，P1 &gt;　P0的概率几位AUC的值</li><li>ROC(Receiver operating characteristic curve)：x轴为假阳率，y轴为真阳率</li><li>假阳率：混淆矩阵中将负样本预测为正样本的数量除以全部预测为正样本的数量，即: FP/（TP+FP）</li><li>真阳率：混淆矩阵中将正样本预测为正样本的数量除以全部预测为正样本的数量，即: TP/（TP+FP）</li><li>召回率：对于样本而言，原来的正样本预测为正样本（TP），正样本预测为负样本（FN），预测为正样本的准确率，TP/(TP+FN)</li><li>精确率：对于预测结果而言，原来正样本预测为正样本（TP），原来负样本预测为正样本（FP），TP/(TP+FP)</li></ul><blockquote><p>初赛数据，解压后近5G，训练数据集有800w+样本，测试数据集200w+，用户数据集有1100w+条目，广告数据集有179条，数据拼接后大小近8G<br>复赛数据，解压后近16G，训练数据集有4500w+样本，测试数据集1100w+，数据拼接后大小近20G</p></blockquote><h1 id="参赛经验"><a href="#参赛经验" class="headerlink" title="参赛经验"></a>参赛经验</h1><p>　　第一次参加比赛，所以毫无经验，不过有大佬开源<a href="https://blog.csdn.net/Bryan__/article/details/79623239" target="_blank" rel="noopener">baseline</a>，在此十分感谢bryan大佬的开源，让第一次参加的小白能够快速入门，还有官方群里的那些开源的大佬。<br>　　参赛的历程如下：<code>学习baseline</code> —-&gt; <code>自己写baseline</code> —-&gt; <code>统计分析做特征(统计特征以及交叉组合统计特征)</code> —-&gt; <code>学习其他模型</code> —-&gt; <code>跑模型并提交成绩</code></p><h2 id="baseline的学习"><a href="#baseline的学习" class="headerlink" title="baseline的学习"></a>baseline的学习</h2><p>　　在你什么都不懂的时候，快速入门其实最好的资料就是有一份完整的代码，能够让你了解到整个流程，包括数据处理，模型选择，参数设计，到最后的模型应用和预测，对着代码，将代码涉及到的所有内容一点点学习，不要求所有的原理全部弄清楚，但是能达到应用和复现的程度。本次比赛的流程图如下：<br>　　<br>　　<img src="/assets/algo/process.png" alt=""><br>　<br>　　baseline的代码包括除了上图模型融合的流程，其余的都包括了，baseline用的模型就只有一个lightgbm（决策树模型，<a href="http://naotu.baidu.com/file/49963808802423ac70d9b57199206132?token=1c587c210f9c0db4" target="_blank" rel="noopener">脑图</a>）</p><h2 id="具体知识点"><a href="#具体知识点" class="headerlink" title="具体知识点"></a>具体知识点</h2><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><pre><code>见pandas入门</code></pre><h3 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h3><ul><li><p>插件<a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="noopener">jupyter_contrib_nbextensions</a></p></li><li><p>单元格多个输出（<a href="http://liuchengxu.org/pelican-blog/jupyter-notebook-tips.html" target="_blank" rel="noopener">更多技巧</a>）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from IPython<span class="selector-class">.core</span><span class="selector-class">.interactiveshell</span> import InteractiveShell</span><br><span class="line">InteractiveShell<span class="selector-class">.ast_node_interactivity</span> = <span class="string">"all"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ul><li>后台运行Python脚本并实施输出<ul><li>使用nohup命令，将输入重定向到nohup.out文件</li><li>使用文件IO，并实时进行缓冲区清楚，file.flush，这样就能及时地将内容写入到文件里</li></ul></li><li>CPU内存占用查看工具：htop，安装<code>sudo apt-get install htop</code></li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul><li>可使用Libsvm格式进行训练，能用极大节约内存(python 接口运行内存需要<strong>100G</strong>，使用Libsvm格式只需要不到<strong>40G</strong>就能训练)</li></ul><h3 id="lightgbm"><a href="#lightgbm" class="headerlink" title="lightgbm"></a>lightgbm</h3><ul><li>支持继续训练，特征必须相同，否者无效</li></ul><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><ul><li>进度条tqdm</li><li>稀疏矩阵存储npz</li><li>文件存储hdf，pickle，json.dump，joblib</li></ul><hr><h3 id="Github代码"><a href="#Github代码" class="headerlink" title="Github代码"></a>Github代码</h3><p>随手一个star，比心！👉👉👉👉👉👉 <a href="https://github.com/jame-zhang/2018_tencent_ad_algo" target="_blank" rel="noopener">传送门</a>👈👈👈👈👈👈</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>项目下有四个目录：</p><ul><li>lgb_libsvm</li><li>ffm代码</li><li>deep_ffm代码</li><li>开源baseline</li></ul><h4 id="lgb-libsvm"><a href="#lgb-libsvm" class="headerlink" title="lgb_libsvm"></a>lgb_libsvm</h4><p>lgb_libsvm下的代码是使用libsvm格式进行lgb训练和预测的代码，这个目录下就是我的写的代码了，ffm和deepffm的则是辉哥整理和编写的代码</p><ul><li>degub文件夹：测试csv转化成libsvm的例子的文件夹</li><li>demo文件夹：小样本demo文件夹<ul><li>twofile：将两个csv文件拼接然后转化为libsvm文件</li></ul></li><li>feature_engineering：基于libsvm格式，lgb去选特征，验证特征工程是否有效<ul><li>offline_datasets：线下测试的数据文件夹(train_test_split为编译过的可执行性文件，chmod +x ，然后./train_test_split就能看到用法，实验室的大佬用C++写的，速度特别快)</li></ul></li><li>iioiio：实验室大佬c++写的数据集验证集划分</li><li>lgb_config：lgb训练参数文件</li><li>Ljh：辉哥整理的特征工程代码</li><li>shell_command：训练流程自动化shell脚本(最后来不及，没用到，也没写完)</li><li>submission：提交结果文件夹</li></ul><h4 id="开源baseline"><a href="#开源baseline" class="headerlink" title="开源baseline"></a>开源baseline</h4><p><a href="https://blog.csdn.net/Bryan__/article/details/79623239" target="_blank" rel="noopener">bryan大佬</a>的开源，帮助了很多跟我一样的小白，在此表示感谢，把baseline吃透，包括one-hot和CountVector，然后对着sklearn的源码和例子看一下，就能了解到特征的基本处理流程，baseline的主要知识点如下：</p><ul><li>数据读取、拼接和转化：原来的4张表拼接成一张表，这里csv转化为pandas的DataFrame，然后使用df(dataframe)进行操作，pandas入门，文件读取和字符串操作(userdata的转化)</li><li>one-hot：<strong>处理离散型数</strong>据，且<strong>相互之间独立没有联系</strong>，由于机器学习中需要用计算机能够表达的形式来表示数据，所以one-hot就是一种处理形式，<a href="https://www.cnblogs.com/lzh-cnblogs/p/3764749.html" target="_blank" rel="noopener">简单介绍</a>（后面再单独写一篇博文介绍下，因为之前看的别人写的都不够全面，包括one-hot的特点，使用意义）</li><li>CountVector：<strong>也是处理离散型数据</strong>，跟BOW（Bog of words）一样</li><li>Lightgbm python接口使用和参数设置</li><li>参数调整</li><li>Lightgbm模型学习(决策树模型、xgboost等)</li></ul><h4 id="FFM代码"><a href="#FFM代码" class="headerlink" title="FFM代码"></a>FFM代码</h4><p>fm和ffm：ffm(filed Factorization Machines)是在fm的基础上改进的，学习资料<a href="https://tech.meituan.com/deep-understanding-of-ffm-principles-and-practices.html" target="_blank" rel="noopener">美团的技术博客</a>、fm(<a href="/assets/algo/Factorization-Machines-with-libFM.pdf">1</a>、<a href="/assets/algo/Factorization-Machines-Rendle2010.pdf">2</a>)和<a href="">ffm</a>(<a href="/assets/algo/deep-fm1804.04950.pdf">1</a>、<a href="/assets/algo/deepFM1703.04247.pdf">2</a>)的论文</p>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/06/14/%E8%85%BE%E8%AE%AF%E5%B9%BF%E5%91%8A%E7%AE%97%E6%B3%95%E5%A4%A7%E8%B5%9B%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>pandas入门</title>
      <link>https://blog.jame-zhang.top/2018/05/03/pandas%E5%85%A5%E9%97%A8/</link>
      <guid>https://blog.jame-zhang.top/2018/05/03/pandas%E5%85%A5%E9%97%A8/</guid>
      <pubDate>Thu, 03 May 2018 02:29:20 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;参加&lt;a href=&quot;http://algo.qq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;腾讯广告算法大赛&lt;/a&gt;，学习pandas使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;学习的材料：&quot;&gt;&lt;a href=&quot;#学习的材料：&quot; class=&quot;headerlink&quot; title=&quot;学习的材料：&quot;&gt;&lt;/a&gt;学习的材料：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;直接搜索(各种博客和网站)&lt;/li&gt;
&lt;li&gt;腾讯广告算法大赛数据操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;常见操作&quot;&gt;&lt;a href=&quot;#常见操作&quot; class=&quot;headerlink&quot; title=&quot;常见操作&quot;&gt;&lt;/a&gt;常见操作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;导入包并读取csv文件&lt;/strong&gt;&lt;br&gt;函数：&lt;code&gt;pd.read_csv(path)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight clean&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df = pd.read_csv(&lt;span class=&quot;string&quot;&gt;&#39;../datasets/train.csv&#39;&lt;/span&gt;) #读取后的格式为DataFrame&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>参加<a href="http://algo.qq.com/" target="_blank" rel="noopener">腾讯广告算法大赛</a>，学习pandas使用</p></blockquote><h1 id="学习的材料："><a href="#学习的材料：" class="headerlink" title="学习的材料："></a>学习的材料：</h1><ul><li>直接搜索(各种博客和网站)</li><li>腾讯广告算法大赛数据操作</li></ul><h1 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h1><ul><li><strong>导入包并读取csv文件</strong><br>函数：<code>pd.read_csv(path)</code></li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'../datasets/train.csv'</span>) #读取后的格式为DataFrame</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>查看数据的某几行</strong><br>函数: <code>head(num)</code>、<code>tail(num)</code></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.head<span class="comment">(5)</span> <span class="attr">#显示前5</span>行</span><br><span class="line">df.tail<span class="comment">(5)</span> <span class="attr">#显示最后5</span>行</span><br></pre></td></tr></table></figure><ul><li><strong>查看数据的大小</strong><br>属性: <code>dataframe.shape</code></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.<span class="keyword">shape </span><span class="comment">#显示dataframe的大小</span></span><br><span class="line">df.<span class="keyword">shape[0] </span><span class="comment">#显示dataframe的长度，即样本数</span></span><br><span class="line">df.<span class="keyword">shape[1] </span><span class="comment">#显示dataframe的宽度，即特征数量</span></span><br></pre></td></tr></table></figure><ul><li><strong>查看数据的统计情况</strong><br>函数: <code>dataframe.describe()</code></li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe() <span class="meta">#统计信息</span></span><br></pre></td></tr></table></figure><ul><li><strong>查看数据的总体情况</strong><br>函数: <code>dataframe.info()</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.<span class="builtin-name">info</span>(<span class="attribute">memory_usage</span>=<span class="string">'deep'</span>) #总体信息</span><br></pre></td></tr></table></figure><ul><li><strong>选取某一列(多列df.[‘aid’,’uid’])</strong></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">df_aid</span> = df[<span class="string">'aid'</span>] #最终返回的是Series</span><br><span class="line"><span class="attr">df_aid_df</span> = df[[<span class="string">'aid'</span>]] #最终返回的是dataframe的类型</span><br></pre></td></tr></table></figure><ul><li><strong>选取某一行</strong><br>索引(index)为数字: <code>dataframe.iloc(30)</code></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_aid.iloc<span class="comment">(30)</span> <span class="attr">#最显示第30</span>行的数据，返回的是Series</span><br></pre></td></tr></table></figure><p>索引(index)为字符: <code>dataframe.iloc(&quot;30&quot;)</code></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_aid.loc(<span class="string">"30"</span>) <span class="meta">#最显示第30行的数据，返回的是Series</span></span><br></pre></td></tr></table></figure><ul><li><strong>选取多行</strong><br>索引(index)为数字: <code>dataframe.iloc(30)</code></li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_aid.iloc([<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>]) #最显示第<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>行的数据，返回的是Series</span><br></pre></td></tr></table></figure><p>索引(index)为字符: <code>dataframe.iloc([&quot;30&quot;,&quot;20&quot;,&quot;10&quot;])</code></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_aid.loc(<span class="string">"30"</span>) #最显示第<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>行的数据，返回的是Series</span><br></pre></td></tr></table></figure><ul><li><strong>修改index</strong><br>修改索引(index)为<code>aid</code>列: <code>dataframe.set_index([&#39;aid&#39;])</code></li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_aid.set_index(['aid']) <span class="meta">#将aid列作为index值</span></span><br></pre></td></tr></table></figure><ul><li><strong>重置index</strong><br>重置索引(index)为数字: <code>dataframe.reset_index()</code></li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_aid.reset_index() <span class="meta">#重置index</span></span><br></pre></td></tr></table></figure><ul><li><strong>按照index进行排序</strong><br>函数: <code>dataframe.sort_index(acending=False)</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df<span class="built_in">..</span>sort_index(<span class="attribute">acending</span>=<span class="literal">False</span>) #按照index进行降序排序</span><br></pre></td></tr></table></figure><ul><li><strong>按照某一列进行排序</strong><br>函数: <code>dataframe.sort_values(by=[&quot;aid&quot;], acending=False)</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by=[<span class="string">"aid"</span>], <span class="attribute">acending</span>=<span class="literal">False</span>) #按照aid列进行降序排序</span><br></pre></td></tr></table></figure><ul><li><strong>更改列名称</strong><br>函数: <code>dataframe.rename()</code></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.<span class="built_in">rename</span>(<span class="built_in">columns</span>=&#123;<span class="string">"aid"</span>:<span class="string">"aid_new"</span>&#125;) #将aid列名改为aid_new</span><br></pre></td></tr></table></figure><h1 id="数据集操作"><a href="#数据集操作" class="headerlink" title="数据集操作"></a>数据集操作</h1><p>原始的数据样本数据量太大，在进行调参和线下测试的时候只取一小部分可以节约时间，所以对数据集进行采样</p><ul><li><strong>分组统计</strong></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">df</span><span class="selector-attr">['aid']</span><span class="selector-class">.value_counts</span>() </span><br><span class="line"><span class="selector-tag">df</span><span class="selector-class">.groupby</span>(by=<span class="string">'aid'</span>)<span class="selector-class">.size</span>()</span><br></pre></td></tr></table></figure><ul><li><strong>查询</strong></li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[df[<span class="string">'aid'</span>] &gt; <span class="number">1000</span>]</span><br></pre></td></tr></table></figure><ul><li><strong>查询唯一的值</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">df</span><span class="selector-attr">['aid']</span><span class="selector-class">.unique</span>()</span><br></pre></td></tr></table></figure><ul><li><strong>小数点后几位保留</strong></li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'score'</span>].round(<span class="number">6</span>) #保留<span class="number">6</span>位</span><br><span class="line">df[<span class="string">'score'</span>] = df[<span class="string">'score'</span>].apply(lambda x: <span class="string">'%.6f'</span> <span class="comment">% x) #保留6位</span></span><br></pre></td></tr></table></figure><ul><li><strong>更改值</strong></li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train.loc[train[<span class="string">'label'</span>]==<span class="number">-1</span>,<span class="string">'label'</span>]=<span class="number">0</span></span><br><span class="line">train[<span class="string">'label'</span>] = train[<span class="string">'label'</span>].map(&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">-1</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/05/03/pandas%E5%85%A5%E9%97%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>What Do We Understand About Convolutional Networks?</title>
      <link>https://blog.jame-zhang.top/2018/04/17/What-Do-We-Understand-About-Convolutional-Networks/</link>
      <guid>https://blog.jame-zhang.top/2018/04/17/What-Do-We-Understand-About-Convolutional-Networks/</guid>
      <pubDate>Tue, 17 Apr 2018 11:32:00 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;卷积神经元网络综述译文，原文共有94页，看论文的时候翻译出来，记录下。&lt;br&gt;原文地址: &lt;a href=&quot;https://arxiv.org/abs/1803.08834&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;arxiv&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div style=&quot;font-size:30px;margin-top:30px&quot; align=&quot;center&quot;&gt;关于卷积神经元网络我们了解什么&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;作者：Isma Hadji and Richard P. Wildes, Department of Electrical Engineering and Computer Science, York University,Toronto, Ontario,Canada.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>卷积神经元网络综述译文，原文共有94页，看论文的时候翻译出来，记录下。<br>原文地址: <a href="https://arxiv.org/abs/1803.08834" target="_blank" rel="noopener">arxiv</a></p></blockquote><div style="font-size:30px;margin-top:30px" align="center">关于卷积神经元网络我们了解什么</div><blockquote><p>作者：Isma Hadji and Richard P. Wildes, Department of Electrical Engineering and Computer Science, York University,Toronto, Ontario,Canada.</p></blockquote><a id="more"></a><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="1-1-写作动机"><a href="#1-1-写作动机" class="headerlink" title="1.1 写作动机"></a>1.1 写作动机</h4><p>　　在过去的几年里，<strong>计算机视觉方面</strong>的研究主要集中在<strong>卷积神经网络</strong>，卷积神经网络也常常被叫做ConvNets或者CNNs。近年来的研究已经达到了最先进的效果，尤其是在大范围的<strong>分类</strong>[64,88,139]和<strong>回归</strong>[36,97,159]问题上。这些实现方法的历史能够追溯到很多年之前[49,91]，然而，相比之下，对于这些方法(系统)是如何达到这样出色的效果的理论研究（理解）却明显拖了后腿。事实上，现阶段很多在计算机视觉领域有显著提升的方法（原文为贡献，这里指的是有贡献的研究方法）都是将卷积神经网络当做黑盒子使用，这种黑盒子在面对为何能够达到这种效果的问题下，即使十分模糊，也依旧能够取得效果，然而从科学的角度出发的话，这个并不能让人满意。特别地，这里主要有两个相互补充的话题: (1)对于机器学习的层面上(比如：卷积核)，具体机器学习到了什么？(2)对于网络结构设计的层面上(比如：神经网络的层数，卷积核或者卷积层的数量，池化的策略，非线性激活函数的选择等)，为什么有些选择会优于别的选择？对于这些问题的答案不仅能够提高卷积神经网络的在理论层面上的认知，也能够提高实际的应用。<br>　　并且，目前对于卷积神经网络的实现需要大量的数据进行训练[84,88,91]，而且已经确定好的决定的设计（？？？不太清楚具体指的什么决定）极大地影响效果[23,77]。更深层次的理论认知应该能够减少数据驱动设计的依赖。当实证研究调查了已实现网络的表现行为，到目前为止，他们的结果极大地限制于内部数据处理的可视化，无法更好去理解在不同卷积网络层所发生的变化[104,133,154]。　　</p><h4 id="1-2-目标"><a href="#1-2-目标" class="headerlink" title="1.2 目标"></a>1.2 目标</h4><p>　　就像上面所提到的问题，这篇文章将会详细地阐述使用多层卷积网络结构的最显著的方法。更重要的是，典型卷积网络结构上各种各样的部分将会通过对不同方法的研究进行讨论，而且是基于在生物学发现或者是声音理论基础上的决策设计。此外，对通过可视化和实证研究去理解卷积网络的不同尝试也会进行讨论。终极目标就是能够清楚阐述设计卷积网络结构的每一层处理的作用，能够提取出我们目前对于卷积网络的认识同时能够强调出重点问题。　　</p><h4 id="1-3-论文概述"><a href="#1-3-论文概述" class="headerlink" title="1.3 论文概述"></a>1.3 论文概述</h4><p>　　这篇文章的结构如下：当前的章节提出了仔细回顾对卷积网络认知的必要性。第二章开始将会描述各种各样的多层网络以及阐述在计算机视觉应用中最好的网络结构。第三章将会集中在典型卷家网络的每一个细节里以及讨论不同组成成分的设计，包括生物学角度和学术理论角度。最后，第四章将会描述目前卷积网络的趋势、跟卷积网络理解有关所做的努力，以及提出目前仍然存在的最大的缺点和问题所在。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="多层网络结构"><a href="#多层网络结构" class="headerlink" title="多层网络结构"></a>多层网络结构</h3><p>　　这一章将会对目前在计算机视觉效果最为突出的多层网络结构给出简要的概述。特别的，这一章尽管会覆盖在文学方面最重要的贡献，但是不会提供详细的结构解析，因为这些可以从别的地方获得[17,56,90]。相反地，这一章的目的是为了提供基础，给其他的文献和相关的详细的介绍以及关于目前对卷积网络再视觉信息处理的讨论。</p><h4 id="2-1-写作动机"><a href="#2-1-写作动机" class="headerlink" title="2.1 写作动机"></a>2.1 写作动机</h4><p>　　在以深度网络为基础的成功之前，最先进的视觉识别系统主要包括两个独立但是互补的步骤。首先，输入的数据通过手工设计的特征进行变换(比如，通过偏差值、局部和全局编码方法卷积)达到适合的形式。<br>　　<br><strong>立个flag，由于忙别的暂时把深度学习放一边，后面学习深度学习的时候，再更新</strong>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/17/What-Do-We-Understand-About-Convolutional-Networks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux命令记录</title>
      <link>https://blog.jame-zhang.top/2018/04/11/Linux%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</link>
      <guid>https://blog.jame-zhang.top/2018/04/11/Linux%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Wed, 11 Apr 2018 02:45:45 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>命令记录，方便自己查找</p></blockquote><ol><li>修改主机名<br><code>ubuntu: 修改/etc/hostname</code></li><li>修改ssh配置<br><code>etc/ssh/ssh_config</code><br><code>etc/ssh/sshd_config</code></li><li>查看端口占用<br><code>netstat -tunlp |grep 80</code></li></ol>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/11/Linux%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ubuntu16.04卡在登录循环</title>
      <link>https://blog.jame-zhang.top/2018/04/10/ubuntu16-04%E5%8D%A1%E5%9C%A8%E7%99%BB%E5%BD%95%E5%BE%AA%E7%8E%AF/</link>
      <guid>https://blog.jame-zhang.top/2018/04/10/ubuntu16-04%E5%8D%A1%E5%9C%A8%E7%99%BB%E5%BD%95%E5%BE%AA%E7%8E%AF/</guid>
      <pubDate>Tue, 10 Apr 2018 06:58:24 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>运气正好，不知道为什么突然实验室的服务器出现问题了，是我装了dokcer的原因吗？<br>问题就是一直卡在登录的界面，密码输入正确后，然后黑屏又跳回来让你重新输入密码登陆，一直循环</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>　　分别百度和谷歌了一下，试了集中方法，最后解决的方法就是：  <strong>更改用户目录的权限</strong>，查看权限的时候发现时<code>drwxr-xr-x</code>，用root用户更改了权限后，权限更改为<code>drwxrwxrwx</code>，发现问题解决了。  </p><p><strong>参考</strong>：</p><ul><li><a href="https://blog.csdn.net/junmuzi/article/details/52253784" target="_blank" rel="noopener">csdn</a></li><li><a href="https://askubuntu.com/questions/223501/ubuntu-gets-stuck-in-a-login-loop" target="_blank" rel="noopener">askubuntu</a></li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/10/ubuntu16-04%E5%8D%A1%E5%9C%A8%E7%99%BB%E5%BD%95%E5%BE%AA%E7%8E%AF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>程序员的站点</title>
      <link>https://blog.jame-zhang.top/2018/04/08/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%AB%99%E7%82%B9/</link>
      <guid>https://blog.jame-zhang.top/2018/04/08/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%AB%99%E7%82%B9/</guid>
      <pubDate>Sun, 08 Apr 2018 11:16:39 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;持续更新&lt;br&gt;更新截止时间：2018-4-8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;代码能力&quot;&gt;&lt;a href=&quot;#代码能力&quot; class=&quot;headerlink&quot; title=&quot;代码能力&quot;&gt;&lt;/a&gt;代码能力&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;leetcode&lt;/li&gt;
&lt;li&gt;lintcode&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;项目能力&quot;&gt;&lt;a href=&quot;#项目能力&quot; class=&quot;headerlink&quot; title=&quot;项目能力&quot;&gt;&lt;/a&gt;项目能力&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;github(当搜索引擎用)&lt;/li&gt;
&lt;li&gt;码云&lt;/li&gt;
&lt;li&gt;开源中国&lt;/li&gt;
&lt;li&gt;coding&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>持续更新<br>更新截止时间：2018-4-8</p></blockquote><h2 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h2><ul><li>leetcode</li><li>lintcode</li></ul><h2 id="项目能力"><a href="#项目能力" class="headerlink" title="项目能力"></a>项目能力</h2><ul><li>github(当搜索引擎用)</li><li>码云</li><li>开源中国</li><li>coding</li></ul><a id="more"></a><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>慕课网</li><li>stackoverflow</li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/08/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E7%AB%99%E7%82%B9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用树莓派搭建你自己的ngrok服务器</title>
      <link>https://blog.jame-zhang.top/2018/04/08/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84ngrok%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <guid>https://blog.jame-zhang.top/2018/04/08/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84ngrok%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <pubDate>Sun, 08 Apr 2018 03:51:18 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;这几天研究ngrok的使用，用谷歌的vps测试了下，发现一起正常，然后突然想到，树莓派能运行服务器端或者运行客户端呢，答案是肯定的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;搭建的探索进程&quot;&gt;&lt;a href=&quot;#搭建的探索进程&quot; class=&quot;headerlink&quot; title=&quot;搭建的探索进程&quot;&gt;&lt;/a&gt;搭建的探索进程&lt;/h2&gt;&lt;h3 id=&quot;按照编译的标准流程&quot;&gt;&lt;a href=&quot;#按照编译的标准流程&quot; class=&quot;headerlink&quot; title=&quot;按照编译的标准流程&quot;&gt;&lt;/a&gt;按照编译的标准流程&lt;/h3&gt;&lt;h4 id=&quot;刚开始想着按照标准的编译流程在树莓派安装环境（go、git、其他依赖），结果失败。&quot;&gt;&lt;a href=&quot;#刚开始想着按照标准的编译流程在树莓派安装环境（go、git、其他依赖），结果失败。&quot; class=&quot;headerlink&quot; title=&quot;刚开始想着按照标准的编译流程在树莓派安装环境（go、git、其他依赖），结果失败。&quot;&gt;&lt;/a&gt;刚开始想着按照标准的编译流程在树莓派安装环境（go、git、其他依赖），结果失败。&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;首先go语言arm架构的软件包需要自己编译，手上的树莓派型号是：树莓派3 B型的机器，架构是armv7，然后到go语言官网只找到了armv6的软件，所以安装了go1.42以上的armv6的软件包（官方文档没有找到版本要求，参考的教程里面用的是1.42版本的，所以自己想当然认为1.42的会比较好，实际上用了高于1.42的也可以），最后安装依赖的时候提示找不到软件&lt;/li&gt;
&lt;li&gt;更新了阿里云的软件源，失败，看来想要在树莓派上走一遍编译流程并不行
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>这几天研究ngrok的使用，用谷歌的vps测试了下，发现一起正常，然后突然想到，树莓派能运行服务器端或者运行客户端呢，答案是肯定的</p></blockquote><h2 id="搭建的探索进程"><a href="#搭建的探索进程" class="headerlink" title="搭建的探索进程"></a>搭建的探索进程</h2><h3 id="按照编译的标准流程"><a href="#按照编译的标准流程" class="headerlink" title="按照编译的标准流程"></a>按照编译的标准流程</h3><h4 id="刚开始想着按照标准的编译流程在树莓派安装环境（go、git、其他依赖），结果失败。"><a href="#刚开始想着按照标准的编译流程在树莓派安装环境（go、git、其他依赖），结果失败。" class="headerlink" title="刚开始想着按照标准的编译流程在树莓派安装环境（go、git、其他依赖），结果失败。"></a>刚开始想着按照标准的编译流程在树莓派安装环境（go、git、其他依赖），结果失败。</h4><ul><li>首先go语言arm架构的软件包需要自己编译，手上的树莓派型号是：树莓派3 B型的机器，架构是armv7，然后到go语言官网只找到了armv6的软件，所以安装了go1.42以上的armv6的软件包（官方文档没有找到版本要求，参考的教程里面用的是1.42版本的，所以自己想当然认为1.42的会比较好，实际上用了高于1.42的也可以），最后安装依赖的时候提示找不到软件</li><li>更新了阿里云的软件源，失败，看来想要在树莓派上走一遍编译流程并不行  <a id="more"></a></li></ul><blockquote><p>做事情避免不了被打断，有时间中断完可能就回不来了，8号上午的文章，9号晚上来补，继续吧</p></blockquote><h4 id="接着想着不就是要一个centos的环境吗，在树莓派跑个docker，装个centos的镜像吧，结果失败"><a href="#接着想着不就是要一个centos的环境吗，在树莓派跑个docker，装个centos的镜像吧，结果失败" class="headerlink" title="接着想着不就是要一个centos的环境吗，在树莓派跑个docker，装个centos的镜像吧，结果失败"></a>接着想着不就是要一个centos的环境吗，在树莓派跑个docker，装个centos的镜像吧，结果失败</h4><p><img src="/assets/pie-ngrok.png" alt=""></p><p>更新软件的时候都失败，看来是arm架构的软件源镜像没人管了，毕竟用的人那么少，只有闲的蛋疼的才会这么做（比如我😂😂），who cares，所以这个方法失败。<br><img src="/assets/pie-docker-error.png" alt=""></p><h3 id="思考了一下发现解决办法（做事情，思考很重要呀）"><a href="#思考了一下发现解决办法（做事情，思考很重要呀）" class="headerlink" title="思考了一下发现解决办法（做事情，思考很重要呀）"></a>思考了一下发现解决办法（做事情，思考很重要呀）</h3><p>　　试了👆的两个方法失败后，冷静地思考了下，发现编译的时候不是会传递架构的参数吗？<code>GOOS=linux GOARCH=amd64 make release-server</code>，而且客户端和服务器认证的时候是通过证书的，所以我只要生成树莓派的证书，然后复制到ngrok的源码里面不就成了吗？结果 –&gt; 成功。<br>所以把ngrok部署在树莓派（可以把树莓派当服务器，或者使用客户端）的办法就是：</p><ul><li>找一台正常环境的centos，安装好编译环境（具体参考<a href="http://www.jame-zhang.top/2018/04/05/ngrok%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">ngrok服务器搭建</a>的文章）</li><li><p>然后在你的<strong>树莓派上生成证书</strong>，<strong>拷贝到编译用的centos</strong>，生成证书的代码是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out rootCA<span class="selector-class">.key</span> <span class="number">2048</span></span><br><span class="line">openssl req -x509 -new -nodes -key rootCA<span class="selector-class">.key</span> -subj <span class="string">"/CN=$NGROK_DOMAIN"</span> -days <span class="number">5000</span> -out rootCA.pem</span><br><span class="line">openssl genrsa -out server<span class="selector-class">.key</span> <span class="number">2048</span></span><br><span class="line">openssl req -new -key server<span class="selector-class">.key</span> -subj <span class="string">"/CN=$NGROK_DOMAIN"</span> -out server.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server<span class="selector-class">.csr</span> -CA rootCA<span class="selector-class">.pem</span> -CAkey rootCA<span class="selector-class">.key</span> -CAcreateserial -out server<span class="selector-class">.crt</span> -days <span class="number">5000</span></span><br></pre></td></tr></table></figure></li><li><p>替代好证书后，就是编译了，编译服务器的时候架构选择arm就行了（把ngrok的服务器部署在树莓派上），如果不知道参数就用<code>go env</code>查看下，前提是你得安装好go语言环境了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/go/src</span><br><span class="line"><span class="attribute">GOOS</span>=linux <span class="attribute">GOARCH</span>=arm ./make.bash  #就是GOARCH这里改成arm64或者arm</span><br><span class="line">cd /usr/local/ngrok/</span><br><span class="line"><span class="attribute">GOOS</span>=linux <span class="attribute">GOARCH</span>=arm make release-server #这是编译arm上的服务器的</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>所以同样的道理，如果你想把你的ngrok放在mac上或者windows上，只要相对应的改成编译的参数就好了。<br>最后只要编译生成的服务器端（主要是服务器端，客户端当然也可以）运行在树莓派上就可以了，运行参数</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ngrok服务端启动命令</span></span><br><span class="line">setsid ./ngrokd <span class="attribute">-domain</span>=<span class="string">"jame-zhang.top"</span> <span class="attribute">-httpAddr</span>=<span class="string">":8080"</span> <span class="attribute">-httpsAddr</span>=<span class="string">":7777"</span> <span class="attribute">-log</span>=stdout <span class="attribute">-log-level</span>=error 2&gt;&amp;1 &gt; /dev/<span class="literal">null</span> &amp; #setsid为设置后台运行模式，<span class="attribute">-log</span>=stdout <span class="attribute">-log-level</span>=error 2&gt;&amp;1 &gt; /dev/<span class="literal">null</span>是设置日志记录的格式，以及将输出直接丢到linux的黑洞里，直接丢弃，不在屏幕上输出</span><br><span class="line"><span class="comment">#客户端启动命令</span></span><br><span class="line">setsid ./ngrok-client-arm <span class="attribute">-config</span>=./ngrok.cfg <span class="attribute">-log</span>=stdout <span class="attribute">-log-level</span>=error <span class="attribute">-subdomain</span>=test 8080 2&gt;&amp;1 &gt; /dev/<span class="literal">null</span> &amp;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/08/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84ngrok%E6%9C%8D%E5%8A%A1%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx的使用</title>
      <link>https://blog.jame-zhang.top/2018/04/06/Nginx%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <guid>https://blog.jame-zhang.top/2018/04/06/Nginx%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Fri, 06 Apr 2018 10:45:01 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;默认目录&quot;&gt;&lt;a href=&quot;#默认目录&quot; class=&quot;headerlink&quot; title=&quot;默认目录&quot;&gt;&lt;/a&gt;默认目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;/var/www/html&lt;/li&gt;
&lt;li&gt;/usr/share/nginx/html&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="默认目录"><a href="#默认目录" class="headerlink" title="默认目录"></a>默认目录</h2><ul><li>/var/www/html</li><li>/usr/share/nginx/html</li></ul><a id="more"></a><h2 id="配置站点跳转"><a href="#配置站点跳转" class="headerlink" title="配置站点跳转"></a>配置站点跳转</h2><ol><li><p>jame-zhang 跳转到 <a href="http://www.jame-zhang.top" target="_blank" rel="noopener">www.jame-zhang.top</a></p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        <span class="attribute">listen 80;</span></span><br><span class="line"><span class="attribute">        server_name jame-zhang.top;</span></span><br><span class="line"><span class="attribute">        return 301 https</span>://www<span class="variable">.jame-zhang</span><span class="variable">.top</span>$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>http跳转到https</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">80</span>;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">server_name</span> www.jame-zhang.top;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span>  https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><p>##　配置多个站点和端口</p><blockquote><p>编辑<code>/etc/nginx/site-enabled/default</code>文件，添加如下代码</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> 自定义端口;</span><br><span class="line">        <span class="attribute">listen</span> [::]:自定义端口;</span><br><span class="line">        <span class="attribute">server_name</span> www.jame-zhang.top;</span><br><span class="line">        <span class="attribute">root</span> 自定义站点路径; <span class="comment">#注意路径最后应该以 /(斜杠) 结尾，否者路径会出错，回到默认站点路径去了</span></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        <span class="comment">#location 配置的是访问的地址</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> html;</span><br><span class="line">        <span class="attribute">index</span> html.index</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>　　Nginx不仅可以作为一个Web服务器或反向代理服务器，还可以按照权重、轮询、ip hash、URL hash等多种方式对后端服务器的负载均衡　　</p><h3 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h3><p>　　负债均衡(load balance)就是将负载分摊到多个操作单元上执行，从而提高服务的可用性和响应速度，带来更好的体验。</p><h3 id="负载均衡的配置"><a href="#负载均衡的配置" class="headerlink" title="负载均衡的配置"></a>负载均衡的配置</h3><p>　　通过Nginx中的upstream指令可以实现负载均衡，在该指令中能够配置负载服务器组。目前负载均衡有4中典型的配置方式，分别为轮询方式、权重方式、ip_hash方式，以及利用第三方模块的方式。</p><ul><li><strong>轮询方式</strong>：负载均衡默认设置方式，每个请求按照时间顺序逐一分配到不同的后端服务器进行处理，如果有服务器宕机，会自动剔除</li><li><strong>权重方式</strong>：利用weight指定轮询的权重比例，与访问率成正比，用于后端服务器性能不均的情况</li><li><strong>ip_hash方式</strong>：每个请求按访问IP的hash结构分配，这样可以使每个访客<strong>固定访问一个后端服务器</strong>，可以<strong>解决Session共享的问题</strong></li><li><strong>第三方模块</strong>：第三方模块采用fair时，按照每台服务器的响应时间来分配请求，响应时间段的优先分配；若第三方模块采用url_hash时，按照访问url的hash值来分配请求<br>　　在upstream置顶的服务器组中，若每个服务器的权重都设置为1（默认值）时，表示当前的负载均衡为轮询方式<h4 id="轮询方式负载均衡"><a href="#轮询方式负载均衡" class="headerlink" title="轮询方式负载均衡"></a>轮询方式负载均衡</h4>　　准备3台服务器（可用虚拟机），全部安装Nginx，IP自己配置或者由系统自动配置，其中一台作为负载均衡服务器，另外两台作为后端Web服务器。<br>　　配置轮询负载均衡：</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置域名为nginx.example.com的虚拟主机</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span> nginx.example.com;</span><br><span class="line"><span class="attribute">location</span> /&#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://web_server;  <span class="comment">#主要就是通过proxy_pass 进行负载均衡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置负载均衡服务器组</span></span><br><span class="line"><span class="attribute">upstream</span> web_server&#123;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.103</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.1.104</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是</strong>：当Nginx检测到后端服务器宕机时，则会在负载均衡服务器自动删除该服务器。</p><h4 id="加权轮询负载均衡"><a href="#加权轮询负载均衡" class="headerlink" title="加权轮询负载均衡"></a>加权轮询负载均衡</h4><p>　　如果负载均衡服务器组中的服务器硬件配置强弱不易，则可以通过weight参数设置权重大小，对于配置较好的服务器，可以设置较高的权值，配置较差的服务器，设置较小的权值，通过加权轮询，可以让每台服务器承担与之硬件配置相符的工作量，从而在整体上发挥最佳的效果。<br>　　与上面配置类似，将其调整为权值轮询。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream web_server&#123;</span><br><span class="line"><span class="built_in">server </span>192.168.1.103 <span class="attribute">weight</span>=1;  </span><br><span class="line"><span class="built_in">server </span>192.168.1.104 <span class="attribute">weight</span>=3; #权值越高，分配的概率越大，权值总和为一次循环，比如，上面104的概率为3/(1+3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中每台服务器负载均衡调度状态设置可以单独设定，参数如下：</p><ul><li><strong>max_fails</strong>：允许请求失败的次数，默认为1，当操作最大次数时，返回proxy_next_upstream指令定义的错误</li><li><strong>fail_timeout</strong>：在经历了max_fails次失败后，暂停服务的时间。且在实际应用中max_fails一般与fail_timeout一起使用</li><li><strong>backup</strong>：预留的备份机器</li><li><strong>down</strong>：表示当前的server暂时不参与负载均衡<br>　　当设置为backup的服务器，只有当所有的非backup机器出现故障或者忙碌的情况下，才会请求backup服务器，因此这台服务器的压力最小</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream web_server&#123;</span><br><span class="line"><span class="built_in">server </span>192.168.1.103 <span class="attribute">weight</span>=1 <span class="attribute">max_fails</span>=1 <span class="attribute">fail_timeout</span>=2;  </span><br><span class="line"><span class="built_in">server </span>192.168.1.104 <span class="attribute">weight</span>=3 <span class="attribute">max_fails</span>=1 <span class="attribute">fail_timeout</span>=2; </span><br><span class="line"><span class="built_in">server </span>192.168.1.105 backup; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ip-hash方式负载均衡"><a href="#ip-hash方式负载均衡" class="headerlink" title="ip_hash方式负载均衡"></a>ip_hash方式负载均衡</h4><p>　　按照IP的hash进行分配，每个IP固定访问一台服务器，能够有效解决Session的共享问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream web_server&#123;</span><br><span class="line">ip_hash;</span><br><span class="line"><span class="built_in">server </span>192.168.1.103 ;  </span><br><span class="line"><span class="built_in">server </span>192.168.1.104 ; </span><br><span class="line"><span class="built_in">server </span>192.168.1.105 down; #使用down标志宕机服务器，不参与分配</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：ip_hash方式处理负载均衡时，不能使用weight和backup设置，同时这种方式可能会导致有些服务器请求少，有些请求比较多，所以只有在必要情况才采用该方式。</p><h4 id="利用第三方模块"><a href="#利用第三方模块" class="headerlink" title="利用第三方模块"></a>利用第三方模块</h4><p>　　第三模块提供很多方式，下面以fair方式为力，按照Web服务器的响应时间实现负载均衡，响应时间段的优先分配，具体实现步骤如下：</p><ol><li><strong>备份已安装Nginx</strong><br>　　由于使用第三方模块需要重新编译Nginx，所以在此之前，需要关闭已经开起的Nginx进程，对已经安装好的Nginx进行备份，便于恢复。</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r <span class="regexp">/usr/</span>local<span class="regexp">/nginx /u</span>sr<span class="regexp">/local/</span>nginx_old</span><br></pre></td></tr></table></figure><ol><li><strong>重新编译安装Nginx</strong><br>　　github上下载fair模块，放到root目录下，重命名，如下</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip nginx-upstream-fair-<span class="literal">master</span>.zip</span><br><span class="line">mv nginx-upstream-fair-<span class="keyword">master</span> <span class="title">nginx-upstream-fair</span></span><br></pre></td></tr></table></figure><p>　　下载Nginx源码，进入解压目录，在编译选项添加<code>nginx-upstream-fair</code> 模块的支持</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> nginx-1.2.7/    <span class="comment">#这里是你下载的nginx的源码解压后的目录</span></span><br><span class="line"><span class="string">./configure</span> \</span><br><span class="line"><span class="params">--prefix=/usr/local/nginx</span> \</span><br><span class="line"><span class="params">--with-http_ssal_module</span> \</span><br><span class="line"><span class="params">--add-module=</span> <span class="string">/root/nginx-upstream-fair</span>  <span class="comment">#这里的目录是你下载的fair模块解压后的目录</span></span><br></pre></td></tr></table></figure><ol><li><strong>配置fair的负载均衡</strong></li></ol><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 配置域名为nginx.example.com的虚拟主机</span></span><br><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">listen <span class="number">80</span>;</span><br><span class="line">server_name nginx.example.com;</span><br><span class="line">location /&#123;</span><br><span class="line">proxy_pass http:<span class="comment">//web_server;  #主要就是通过proxy_pass 进行负载均衡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#配置负载均衡服务器组</span></span><br><span class="line">upstream web_server&#123;</span><br><span class="line"><span class="keyword">server</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span>;</span><br><span class="line"><span class="keyword">server</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.104</span>;</span><br><span class="line">fair;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h2><p>　　待续</p><p>参考：</p><ul><li>Nginx 高性能Web服务器实战教程 - 黑马程序员 </li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/06/Nginx%E7%9A%84%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>网站推荐--uzer.me,强烈推荐！！</title>
      <link>https://blog.jame-zhang.top/2018/04/06/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90-uzer-me-%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90%EF%BC%81%EF%BC%81/</link>
      <guid>https://blog.jame-zhang.top/2018/04/06/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90-uzer-me-%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90%EF%BC%81%EF%BC%81/</guid>
      <pubDate>Fri, 06 Apr 2018 03:27:24 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt; 今天打开Docker的官方文档，发现打不开，换了两台机子（同一个局域网，同一个公网IP）还是打不开，然后突然想到了uzer.me，里面有火狐浏览器（可以自由的浏览网页），发现可以很顺利地打开，最后发现更换了实验室的网络，就可以打开了，可能是docs.docker.com对某些IP进行访问限制了吧，不清楚，言归正传，给大家推荐一个利器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/uzerme/uzerme.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p> 今天打开Docker的官方文档，发现打不开，换了两台机子（同一个局域网，同一个公网IP）还是打不开，然后突然想到了uzer.me，里面有火狐浏览器（可以自由的浏览网页），发现可以很顺利地打开，最后发现更换了实验室的网络，就可以打开了，可能是docs.docker.com对某些IP进行访问限制了吧，不清楚，言归正传，给大家推荐一个利器。</p></blockquote><p><img src="/assets/uzerme/uzerme.png" alt=""></p><a id="more"></a><h2 id="uzer-me"><a href="#uzer-me" class="headerlink" title="uzer.me"></a>uzer.me</h2><p>　　有没有遇到这种情况，有时候外出临时用电脑改文件什么的，但是因为不是自己的电脑，别人电脑没有软件呀，需要安装特定的软件，比如：PS、Excel、Visio、AutoCAD、MATLAB等，然后为了及时赶任务，只能重新找一台有自己需要软件的电脑，或者只能默默地下载安装软件，然后用完再卸载。如果经常这样的话，那么uzer.me对你来说就是特别方便了。</p><p>　　云应用、轻应用，打开浏览器软件直接就能用，支持的软件如下：<br>　　<br><img src="/assets/uzerme/uzerme2.png" alt=""></p><p><strong>而且软件还一直在更新和增加</strong>，我当时去年用的时候还只有少数几款，现在已经有将近20款了。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>注册后，<font style="color:red;font-size:20px;font-weight:bold;font-style:italic;">打开浏览器直接就能用</font></li><li>软件都是注册过的，所以基本没有使用限制</li><li><div style="color:red;font-size:20px;font-weight:bold;font-style:italic;">火狐浏览器可以自由地查资料</div></li><li><p>个人存储空间（虽然只有1G，但是已经满足了，没有办法扩展，也没付费版的）</p><p>网站也有客户端提供下载，不过跟打开网页是一样的，可能连接会好一点。</p></li></ul><p><img src="/assets/uzerme/uzerme-app.png" alt=""></p><p><strong>如果你觉得还不错，就留个评论吧，给下反馈。</strong><br>评论系统挂掉了，看来大众化的评论系统不会有生存的空间的，除非你备案。   </p><p>　　</p>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/06/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90-uzer-me-%E5%A2%99%E8%A3%82%E6%8E%A8%E8%8D%90%EF%BC%81%EF%BC%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>软件列表记录</title>
      <link>https://blog.jame-zhang.top/2018/04/05/%E8%BD%AF%E4%BB%B6%E5%88%97%E8%A1%A8%E8%AE%B0%E5%BD%95/</link>
      <guid>https://blog.jame-zhang.top/2018/04/05/%E8%BD%AF%E4%BB%B6%E5%88%97%E8%A1%A8%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Thu, 05 Apr 2018 12:34:17 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;/assets/software/software.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/assets/software/software.jpg" alt=""><br><a id="more"></a></p><blockquote><p>常用软件记录列表</p></blockquote><ul><li><strong>SSH工具</strong>：mac - vssh、widonws - secure shell client、<a href="https://www.putty.org/" target="_blank" rel="noopener">putty</a></li><li><strong>音质检测工具</strong>：<a href="http://spek.cc/" target="_blank" rel="noopener">spek</a></li><li><strong>Linux启动盘制作工具</strong>：<a href="https://cn.ultraiso.net/" target="_blank" rel="noopener">UltraIOS</a>、Universal USB Installer(给DELL 1950安装CENTOS7 出现 dracut-initqueue timeout，换用Rufus)、Rufus</li><li><strong>路由器开源固件</strong>：openwrt-lede、 padavan、pandorabox</li><li><strong>同步软件</strong>: BT sync、freefilesync、微力同步、syncthing.net</li><li><strong>个人私有云</strong>: owncloud、nextcloud、filebrowser(file manager)、kodcloud、<a href="http://www.filerun.com/" target="_blank" rel="noopener">Filerun</a></li><li><strong>文件传输</strong>: filezilla、scp（命令）</li><li><strong>专用代理软件</strong>：softether(需要梯子)、Openvpn、shadowsocks、Socks5、https、赛风、自由门、蓝灯</li><li>服务器监控项目:  <a href="https://github.com/cppla/ServerStatus" target="_blank" rel="noopener">ServerStatus</a>、<a href="https://github.com/firehol/netdata" target="_blank" rel="noopener">netdata</a></li><li>新生编程语言：kotlin、swift、scalars</li><li>函数式编程语言：scala、clojure</li><li>反向代理服务器: nginx、Squid</li><li>穿墙软件：<a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">ngrok</a>、<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a></li><li>软件下载网站: <a href="https://en.softonic.com/" target="_blank" rel="noopener">softonic</a></li><li>广告屏蔽软件: pi-hole</li><li>文档网站快速生成工具: <a href="https://docsify.js.org/#/zh-cn/" target="_blank" rel="noopener">docsify</a></li><li>代码托管: github、coding、<a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>、<a href="code.aliyun.com">阿里code</a>、gitlab、Bitbucket</li><li>个人信息生成：<a href="www.fakenamegenerator.com">fakenamegenerator</a></li><li>密码管理工具：<a href="https://1password.com/" target="_blank" rel="noopener">1Password</a>、<a href="https://www.lastpass.com/" target="_blank" rel="noopener">LastPass</a>、<a href="https://keepass.info/" target="_blank" rel="noopener">KeePass</a></li><li><strong>在线画图工具</strong>：<a href="https://processon.com/" target="_blank" rel="noopener">processon</a>、<a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a>、<a href="www.lucidchart.com">lucidchart</a></li><li>当前文件夹打开终端(MAC): <a href="https://itunes.apple.com/us/app/go2shell/id445770608?mt=12" target="_blank" rel="noopener">Go2Shell</a></li><li><strong>油猴脚本管理器(chrome浏览器的小程序)</strong>：<a href="http://tampermonkey.net/" target="_blank" rel="noopener">tampermonkey</a>、<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">脚本下载</a>、<a href="https://www.zhihu.com/question/22210090" target="_blank" rel="noopener">知乎推荐的插件</a></li><li>自动部署工具: <a href="https://jenkins.io/" target="_blank" rel="noopener">jenkins</a></li><li>时间自动联网更新: ntpdate</li><li>MAC终端：on-my-zsh、fish、iteam2</li><li><strong>IT培训（主要是人工智能方向）</strong>：太阁、黑马程序员、七月、炼数成金、优达学城、EDX、Coursera、网易云课堂、慕课网</li></ul><p>##多个服务器传输文件方法</p><ul><li>利用nginx</li><li>利用scp</li><li>filezilla</li><li>利用文件管理工具软件，如:owncloud、nextcloud、<a href="https://github.com/filebrowser/filebrowser" target="_blank" rel="noopener">filemanager</a></li></ul><p>##把github当做网盘、当做项目集市</p><blockquote><p>可以把github、docker hub当做代码和文件备份<br>可以多多了解github上的开源项目，进行了解和使用</p></blockquote><p>##在线ide</p><ul><li>amazon cloud9</li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/05/%E8%BD%AF%E4%BB%B6%E5%88%97%E8%A1%A8%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker命令</title>
      <link>https://blog.jame-zhang.top/2018/04/05/Docker%E5%91%BD%E4%BB%A4/</link>
      <guid>https://blog.jame-zhang.top/2018/04/05/Docker%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Thu, 05 Apr 2018 10:35:01 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;Docker常用命令介绍，持续更新&lt;br&gt;了解命令的详细情况可以用 &lt;code&gt;man docker 具体命令&lt;/code&gt;，如：&lt;code&gt;man docker images&lt;/code&gt;查看介绍，跟官方文档一致。  &lt;/p&gt;
&lt;p&gt;更新截止时间：2018-04-10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Docker镜像操作&quot;&gt;&lt;a href=&quot;#Docker镜像操作&quot; class=&quot;headerlink&quot; title=&quot;Docker镜像操作&quot;&gt;&lt;/a&gt;Docker镜像操作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看镜像（&lt;code&gt;-a&lt;/code&gt;参数显示所有镜像，包括临时）  &lt;/p&gt;
&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;docker images&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载镜像&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;docker&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pull&lt;/span&gt; &lt;span class=&quot;selector-id&quot;&gt;#eg&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:docker&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pull&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;repository&lt;/span&gt;/&lt;span class=&quot;selector-tag&quot;&gt;images_name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为镜像添加自定义标签&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker &lt;span class=&quot;keyword&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ubuntu&lt;/span&gt;:latest mybuntu:latest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>Docker常用命令介绍，持续更新<br>了解命令的详细情况可以用 <code>man docker 具体命令</code>，如：<code>man docker images</code>查看介绍，跟官方文档一致。  </p><p>更新截止时间：2018-04-10</p></blockquote><h2 id="Docker镜像操作"><a href="#Docker镜像操作" class="headerlink" title="Docker镜像操作"></a>Docker镜像操作</h2><ol><li><p>查看镜像（<code>-a</code>参数显示所有镜像，包括临时）  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure></li><li><p>下载镜像</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> <span class="selector-id">#eg</span><span class="selector-pseudo">:docker</span> <span class="selector-tag">pull</span> <span class="selector-tag">repository</span>/<span class="selector-tag">images_name</span></span><br></pre></td></tr></table></figure></li><li><p>为镜像添加自定义标签</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">tag</span> <span class="title">ubuntu</span>:latest mybuntu:latest</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol><li>修改默认源为国内<br>配置文件为<code>/etc/docker/daemon.json</code>，添加上 registry-mirrors 键值：</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">其他镜像源：</span><br><span class="line"></span><br><span class="line">* **网易**: `http:<span class="comment">//hub-mirror.c.163.com`</span></span><br><span class="line">* **USTC**: `https:<span class="comment">//docker.mirrors.ustc.edu.cn`</span></span><br><span class="line"></span><br><span class="line">再次使用`docker images`查看镜像，可以看到多了一个拥有mybuntu:latest标签的镜像，之后就可以直接使用myubuntu:latest 来表示这个镜像了，myubuntu:latest的id跟ubuntu:latest是一致的，因为他们是同一个镜像文件，只是别名不同而已，docker tag 命令添加的标签实际上起到了类似链接的作用。</span><br><span class="line"></span><br><span class="line">### 使用inspect 命令查看详细信息</span><br><span class="line">使用`docker inspect`可以获取该镜像的详细信息，包括制作者、适应框架、各层的数字摘要等   </span><br><span class="line">`docker inspect ubuntu:latest`  </span><br><span class="line">返回的是json格式的消息，如果只需要其中某项内容是，可以用`-f`参数，如  </span><br><span class="line">`docker inspect -f&#123;&#123;<span class="string">".Architecture"</span>&#125;&#125;`</span><br><span class="line">### 使用history 命令查看镜像历史</span><br><span class="line">使用history查看镜像每个层的具体内容，如：   </span><br><span class="line">`docker history ubuntu:latest`  </span><br><span class="line">**可以添加 --no-trunc=true 参数来查看完整内容**</span><br><span class="line"></span><br><span class="line">### 容器运行失败，查看失败原因</span><br><span class="line">两种方法:</span><br><span class="line"></span><br><span class="line">* `docker run -it ··· ` 将运行情况输出到屏幕上</span><br><span class="line">* `docker logs id或者容器名` </span><br><span class="line"></span><br><span class="line">### 运行容器时，映射端口</span><br></pre></td></tr></table></figure><p>docker run -p 80:80 image_name  #将本机的80端口与容器内的80绑定<br>docker run -p 700-800:700-800 image_name  #将本机的700到800的端口与容器内的700到800绑定<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Docker容器操作 </span><br><span class="line">### 如何进入到已经创建的容器里面 </span><br><span class="line">这里应该分两种：</span><br><span class="line"></span><br><span class="line">* 一种是直接进入镜像所运行的程序，比如有程序在进行，然后输入内容打印在stdos上，你进入后就直接可以看到程序运行的输出的。</span><br><span class="line">* 另外一种是进入到镜像的环境里面，执行相对应的bash命令等  </span><br><span class="line">两种方式的命令如下：</span><br></pre></td></tr></table></figure></p><p>docker attach 已运行容器名称或者容器ID #直接进入容器<br>docker exec -it 已运行容器名称或者容器ID /bin/bash #执行bash命令<br>Docker-compose exec 与docker exec -it 等同，即Docker-compose默认分配<br><code>`</code><br>如何退出容器而不停止容器？按键<code>ctrl p</code>+<code>ctrl q</code> （distach from docker）<br><a href="https://medium.com/@RyanDavidson/run-bash-or-any-command-in-a-docker-container-9a1e7f0ec204" target="_blank" rel="noopener">reference</a></p><ul><li><code>docker top</code>：可以查看容器中正在运行的进程</li></ul><h3 id="Docker配置文件目录"><a href="#Docker配置文件目录" class="headerlink" title="Docker配置文件目录"></a>Docker配置文件目录</h3><p><code>/var/lib/docker/</code></p>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/05/Docker%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ngrok服务器搭建</title>
      <link>https://blog.jame-zhang.top/2018/04/05/ngrok%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</link>
      <guid>https://blog.jame-zhang.top/2018/04/05/ngrok%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</guid>
      <pubDate>Thu, 05 Apr 2018 08:26:17 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;如果你只是需要穿墙工具，并且是自己架设服务器的话，&lt;strong&gt;不要用ngrok了&lt;/strong&gt;，这个是我研究Ngrok用法一个星期之后的教训，直接用&lt;a href=&quot;https://github.com/fatedier/frp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;frp&lt;/a&gt;既简单又方便，ngrok基本无法配置多端口，自己架设服务器，我是没有整明白，不知道作者是什么脑回路，没开放一个端口好像就得运行一个服务端，客户端可以配置。&lt;strong&gt;总之，要用穿墙服务直接用frp吧，frp就是在ngrok的基础上重新开发的&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ngrok是内网穿透的一个工具，支持http、tcp协议，构建过程出现了点问题&lt;br&gt;最总解决办法：找了有80,443,端口的机子试了下，然后再查看帮助，ngrok -h，更改端口，发现一切正常&lt;br&gt;客户端开始运行是显示的是127.0.0.1:端口，连接成功后才显示域名–&amp;gt;127.0.0.1:端口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/pie-ngrok/ngrok-progress.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上面图是我用processon画的服务运行原理图，可以看到其实ngrok就像是反向代理服务器&lt;/strong&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如果你只是需要穿墙工具，并且是自己架设服务器的话，<strong>不要用ngrok了</strong>，这个是我研究Ngrok用法一个星期之后的教训，直接用<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a>既简单又方便，ngrok基本无法配置多端口，自己架设服务器，我是没有整明白，不知道作者是什么脑回路，没开放一个端口好像就得运行一个服务端，客户端可以配置。<strong>总之，要用穿墙服务直接用frp吧，frp就是在ngrok的基础上重新开发的</strong></p><blockquote><p>ngrok是内网穿透的一个工具，支持http、tcp协议，构建过程出现了点问题<br>最总解决办法：找了有80,443,端口的机子试了下，然后再查看帮助，ngrok -h，更改端口，发现一切正常<br>客户端开始运行是显示的是127.0.0.1:端口，连接成功后才显示域名–&gt;127.0.0.1:端口</p></blockquote><p><img src="/assets/pie-ngrok/ngrok-progress.png" alt=""></p><p><strong>上面图是我用processon画的服务运行原理图，可以看到其实ngrok就像是反向代理服务器</strong></p><a id="more"></a><p>　　如何搭建自己的ngrok服务器，详细可以看github上的<a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">ngrok</a>项目里的doc文件夹里面的文档和README文件：  </p><ol><li>配置好环境，git,go(参考的博客是基于1.42的基础上的，所以推荐安装1.42，<del>其他版本没试过</del>，实际上高于1.42的是可以的)</li><li>按照步骤配置</li></ol><ul><li><p><strong>下载ngrok源码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/inconshreveable/ngrok.git</span><br><span class="line"><span class="built_in">export</span> GOPATH=/usr/<span class="built_in">local</span>/ngrok/</span><br><span class="line"><span class="built_in">export</span> NGROK_DOMAIN=<span class="string">"jame-zhang.tops"</span> <span class="comment">#改成自己的域名</span></span><br></pre></td></tr></table></figure></li><li><p><strong>生成证书</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ngrok <span class="comment">#进入源码的文件夹里面</span></span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj <span class="string">"/CN=<span class="variable">$NGROK_DOMAIN</span>"</span> -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line">openssl req -new -key server.key -subj <span class="string">"/CN=<span class="variable">$NGROK_DOMAIN</span>"</span> -out server.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 5000</span><br></pre></td></tr></table></figure></li><li><p><strong>配置自己的证书到项目里面</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp rootCA.pem assets/client/tls/ngrokroot.crt</span><br><span class="line">cp server.crt assets/server/tls/snakeoil.crt</span><br><span class="line">cp server.key assets/server/tls/snakeoil.key</span><br></pre></td></tr></table></figure></li><li><p><strong>指定编译环境变量，如何确认GOOS和GOARCH，可以通过go env来查看</strong><br>编译服务端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/go/src</span><br><span class="line">GOOS=linux GOARCH=386 ./make.bash</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/ngrok/</span><br><span class="line">GOOS=linux GOARCH=amd64 make release-server</span><br></pre></td></tr></table></figure></li></ul><p>编译mac客户端：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/go/src   #这步很重要，需要先编译，再生成，否者报错</span><br><span class="line"><span class="attribute">GOOS</span>=darwin <span class="attribute">GOARCH</span>=amd64 ./make.bash</span><br><span class="line">cd /usr/local/ngrok/</span><br><span class="line"><span class="attribute">GOOS</span>=darwin <span class="attribute">GOARCH</span>=amd64 make release-client</span><br></pre></td></tr></table></figure></p><p>编译windows客户端：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/go/src   #这步很重要，需要先编译，再生成，否者报错</span><br><span class="line"><span class="attribute">GOOS</span>=windows <span class="attribute">GOARCH</span>=amd64 ./make.bash</span><br><span class="line">cd /usr/local/ngrok/</span><br><span class="line"><span class="attribute">GOOS</span>=windows <span class="attribute">GOARCH</span>=amd64 make release-client</span><br></pre></td></tr></table></figure></p><ul><li><strong>客户端配置文件</strong><br>文件名:ngrok.cfg  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server_addr:</span> <span class="string">"example.com:4443"</span></span><br><span class="line"><span class="string">trust_host_root_certs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>服务端启动</strong>  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/ngrok/bin/ngrokd <span class="attribute">-domain</span>=<span class="string">"<span class="variable">$NGROK_DOMAIN</span>"</span> <span class="attribute">-httpAddr</span>=<span class="string">":80"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>客户端启动</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ngrok <span class="attribute">-config</span>=./ngrok.cfg <span class="attribute">-subdomain</span>=blog 80</span><br><span class="line">setsid ./ngrok <span class="attribute">-config</span>=./ngrok.cfg <span class="attribute">-subdomain</span>=test 80 #在linux下如果想后台运行</span><br></pre></td></tr></table></figure></li></ul><h3 id="几点注意事项"><a href="#几点注意事项" class="headerlink" title="几点注意事项"></a>几点注意事项</h3><ol><li>为了避免防火墙问题导致转发失败，推荐直接用关闭防火墙的vps进行测试和布置，在你测试成功后再更改对应的端口；</li><li>某位大神跟我说ngrok有内存泄露问题，不会回收释放内存，实际情况还没有验证，所以推荐使用frp。</li></ol><h3 id="ngrok内存泄露问题"><a href="#ngrok内存泄露问题" class="headerlink" title="ngrok内存泄露问题"></a>ngrok内存泄露问题</h3><ul><li><a href="http://txren.cc/bianchenghuanjing/3.html" target="_blank" rel="noopener">参考文章</a></li><li><a href="https://github.com/jame-zhang/python-ngrok" target="_blank" rel="noopener">客户端解决方法</a></li></ul><h3 id="ngrok替代品"><a href="#ngrok替代品" class="headerlink" title="ngrok替代品"></a>ngrok替代品</h3><p><strong>frp</strong></p><p>参考：  </p><ul><li><a href="https://www.sunnyos.com/article-show-48.html" target="_blank" rel="noopener">sunny博客</a></li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/05/ngrok%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ubuntu系统安装</title>
      <link>https://blog.jame-zhang.top/2018/04/04/Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</link>
      <guid>https://blog.jame-zhang.top/2018/04/04/Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</guid>
      <pubDate>Wed, 04 Apr 2018 07:09:28 GMT</pubDate>
      <description>
      
        &lt;p&gt;　　安装Ubuntu系统时提示：&lt;br&gt;&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;no&lt;/span&gt;&lt;span class=&quot;built_in&quot;&gt; default &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; UI configuration directive found boot&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;百度查了下，说问题是：  &lt;/p&gt;
&lt;p&gt;解决的办法就是把ioslinux文件夹名称改成syslinux，同时把这个目录下的isolinux.cfg改成syslinux.cfg。再次启动，就可以进入安装界面了。&lt;/p&gt;
&lt;p&gt;最后用电脑上的Parallels虚拟机打开镜像发现同一个问题，所以才知道原来是&lt;strong&gt;镜像下载的时候出现了问题&lt;/strong&gt;。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>　　安装Ubuntu系统时提示：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">no</span><span class="built_in"> default </span><span class="keyword">or</span> UI configuration directive found boot</span><br></pre></td></tr></table></figure></p><p>百度查了下，说问题是：  </p><p>解决的办法就是把ioslinux文件夹名称改成syslinux，同时把这个目录下的isolinux.cfg改成syslinux.cfg。再次启动，就可以进入安装界面了。</p><p>最后用电脑上的Parallels虚拟机打开镜像发现同一个问题，所以才知道原来是<strong>镜像下载的时候出现了问题</strong>。<br><a id="more"></a><br>最终解决办法：</p><ol><li>重新到<a href="https://www.ubuntu.com/download/alternative-downloads" target="_blank" rel="noopener">Ubuntu官网</a>下载镜像文件;</li><li>利用Parallels Desktop检查镜像，确认镜像没有问题</li><li>重新使用UltraISO制作启动盘，然后安装系统</li></ol><h4 id="安装过程好像一起正常，启动的时候卡在no-caching-page-mode-found，只能重新解决问题了"><a href="#安装过程好像一起正常，启动的时候卡在no-caching-page-mode-found，只能重新解决问题了" class="headerlink" title="安装过程好像一起正常，启动的时候卡在no caching page mode found，只能重新解决问题了"></a>安装过程好像一起正常，启动的时候卡在no caching page mode found，只能重新解决问题了</h4><h2 id="分区挂载"><a href="#分区挂载" class="headerlink" title="分区挂载"></a>分区挂载</h2><p>　　这里说下linux系统的分区挂载，Linux文件即目录，所以硬盘分区就是一个文件夹，所需要的分区为:</p><ul><li>swap，交换分区，用于物理内存不足时，把硬盘的一小块空间当做内存使用；</li><li>/,根分区，所有其他文件的分区，推荐50-100个G</li><li>/home，用户文件分区，用户文件的存放区域，建议大一点</li></ul><blockquote><p>设置上面三个分区就可以了，其他分区可以根据个人需要自行修改</p></blockquote>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/04/Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Ubuntu源更新</title>
      <link>https://blog.jame-zhang.top/2018/04/04/Ubuntu%E6%BA%90%E6%9B%B4%E6%96%B0/</link>
      <guid>https://blog.jame-zhang.top/2018/04/04/Ubuntu%E6%BA%90%E6%9B%B4%E6%96%B0/</guid>
      <pubDate>Wed, 04 Apr 2018 03:00:42 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;最近实验室一台浪潮NF5270M3的机子需要重新配置环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看系统信息的命令:  &lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;uname -&lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lsb_release -&lt;span class=&quot;keyword&quot;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>最近实验室一台浪潮NF5270M3的机子需要重新配置环境</p></blockquote><p>查看系统信息的命令:  </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -<span class="keyword">a</span></span><br><span class="line">lsb_release -<span class="keyword">a</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>系统输出如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@fbi</span>-<span class="symbol">NF5270M3:</span>~<span class="regexp">/Jame/linux</span>_amd64<span class="comment"># uname -a</span></span><br><span class="line">Linux fbi-NF5270M3 <span class="number">4.8</span>.<span class="number">0</span>-<span class="number">59</span>-generic <span class="comment">#64-Ubuntu SMP Thu Jun 29 19:38:34 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">root<span class="variable">@fbi</span>-<span class="symbol">NF5270M3:</span>~<span class="regexp">/Jame/linux</span>_amd64<span class="comment"># lsb_release -a</span></span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor <span class="symbol">ID:</span>Ubuntu</span><br><span class="line"><span class="symbol">Description:</span>Ubuntu <span class="number">16.10</span></span><br><span class="line"><span class="symbol">Release:</span><span class="number">16.10</span></span><br><span class="line"><span class="symbol">Codename:</span>yakkety</span><br></pre></td></tr></table></figure><p>Linux系统的配置文件都在/etc下，ubuntu使用的是apt包管理</p><ul><li><strong>备份原来的软件源</strong>：<br><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code>  </li><li><strong>编辑源列表文件(可用vi、nano或者其他文档编辑器)</strong>:<br><code>sudo nano /etc/apt/sources.list</code></li><li>删除文本里的内容，添加新的源地址：  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename-security main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename-updates main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename-proposed main restricted universe multiverse</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename-backports main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename-security main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename-updates main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.<span class="number">163</span>.com<span class="regexp">/ubuntu/</span> Codename-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></li></ul><p>　　以上的配置中，前面的http地址代表的是源的地址，可以根据自己需要自行更换，有阿里云、中科大、网易(mirrors.163.com)等镜像源地址，需要不同的镜像地址，百度搜索一下就可以了，表明版本的就是关键字“Codename”，这是Ubuntu表示版本的一种形式(Ubuntu称其为Codename)，它即对应了一个发行版。版本号和Codename的对应关系如下表。这里只需要将上面的Codename字符串替换为下文中具体的Codename即可。<br><strong>版本号    Codename</strong><br>11.04:  natty<br>11.10:  oneiric<br>12.04:  precise<br>12.10:  quantal<br>13.04:  raring<br>13.10:  saucy<br>14.04:  trusty<br>14.10:  utopic<br>15.04:  vivid<br>15.10:  wily<br>16.04:  xenial<br>16.10:  yakkety<br>……<br>　　更改完以后输入<code>apt-get update</code>更新下　</p><h2 id="更新是卡住的解决办法"><a href="#更新是卡住的解决办法" class="headerlink" title="更新是卡住的解决办法"></a>更新是卡住的解决办法</h2><p>使用<code>apt-get update</code>，然后卡住，把源更新成阿里云的源就可以了，先备份，然后更改文件里的地址</p><p><strong>参考：</strong></p><ol><li><a href="https://blog.csdn.net/zgljl2012/article/details/79065174" target="_blank" rel="noopener">CSDN博客</a></li><li><a href="https://www.linuxidc.com/Linux/2017-03/141589.htm" target="_blank" rel="noopener">Linux公社</a><br>附：<br><a href="https://www.linuxidc.com/Linux/2016-12/138289.htm" target="_blank" rel="noopener">开源软件系统官方源、镜像源Open Source 汇总</a></li></ol>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/04/Ubuntu%E6%BA%90%E6%9B%B4%E6%96%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Mac上的无损音乐播放器</title>
      <link>https://blog.jame-zhang.top/2018/04/02/Mac%E4%B8%8A%E7%9A%84%E6%97%A0%E6%8D%9F%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</link>
      <guid>https://blog.jame-zhang.top/2018/04/02/Mac%E4%B8%8A%E7%9A%84%E6%97%A0%E6%8D%9F%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</guid>
      <pubDate>Mon, 02 Apr 2018 12:33:10 GMT</pubDate>
      <description>
      
        
        
          &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li>VOX</li><li>foobar2000</li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/04/02/Mac%E4%B8%8A%E7%9A%84%E6%97%A0%E6%8D%9F%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Golang指针与JSON</title>
      <link>https://blog.jame-zhang.top/2018/03/29/Golang%E6%8C%87%E9%92%88%E4%B8%8EJSON/</link>
      <guid>https://blog.jame-zhang.top/2018/03/29/Golang%E6%8C%87%E9%92%88%E4%B8%8EJSON/</guid>
      <pubDate>Thu, 29 Mar 2018 14:55:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;/assets/Go/golang.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="/assets/Go/golang.jpg" alt=""><br><a id="more"></a></p><blockquote><p>这周感觉事情好多，好忙，所以到现在GoLang的PPT还没准备，周五云计算课要就大家讲介绍Go语言的部分知识，想着做PPT，不如记录在这里。</p></blockquote><h2 id="什么是GoLang"><a href="#什么是GoLang" class="headerlink" title="什么是GoLang"></a>什么是GoLang</h2><p>  首先编程语言分为机器语言、汇编语言和高级语言（分类不同，有的还多分了脚本语言），其中高级语言又可以分为面向对象和面向过程。</p><blockquote><p>下面介绍都是根据自己的理解所写的，所以不能保证100%正确和通俗易懂（官方的解释请善用搜索引擎）</p></blockquote><ul><li>机器语言就是直接用二进制01进行表示的计算机程序和指令（会机器语言的人得有多厉害的记忆力，太可怕了，目前没遇到过），比如：0000 代表 加载（LOAD）、0001代表存储（STORE）等等，就是给每个指令编码，然后写出各种毫无逻辑的指令编码，不像高级语言，至少有自然语言的元素，有些单词还是能够看得懂的。</li><li>汇编语言就是比机器语言抽象了一层的编程语言，汇编语言就有了自然语言的成分了，有些直接就是单词，比如：MOV、ADD、SUB、PUSH等指令，高级语言都会有编译过程， 在编译成机器代码之前，会保留汇编语言，之前弄过反编译和内存分析，就是用的OD（ollydbg)把exe导入，然后就可以看到程序是怎么运行的，内存是怎么变化的，OD显示分析的就是汇编的代码。</li><li>高级语言有好多种，我接触过的有C,C++,C#,JAVA,PYTHON等，接触的最早的就是C语言了，而且但是开发单片机做机器人比赛的，用的STC51、STM32、飞思卡尔K60用的都是C。<code>计算机语言具有高级语言和低级语言之分</code>。而高级语言又主要是相对于汇编语言而言的，它是较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序。编写的程序称之为源程序。(来自百度百科)</li></ul><h5 id="所以GoLang就是谷歌2009发布的第二款开源编程语言，而且是属于高级语言。"><a href="#所以GoLang就是谷歌2009发布的第二款开源编程语言，而且是属于高级语言。" class="headerlink" title="所以GoLang就是谷歌2009发布的第二款开源编程语言，而且是属于高级语言。"></a>所以<code>GoLang</code>就是谷歌2009发布的第二款开源编程语言，而且是属于高级语言。</h5><blockquote><p>扯了那么多，终于回到轨道上了。</p></blockquote><h2 id="Go语言指针"><a href="#Go语言指针" class="headerlink" title="Go语言指针"></a>Go语言指针</h2><p>  学过C语言的时候，都知道<code>指针</code>是什么？指针简单理解起来就是用来存储内存地址的一个数据类型，各种变量和函数（也有函数指针）存储在计算机里面都会有存储地址，而这个地址就可以用指针来存和被指针引用。<br><code>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。</code>    </p><p>以下实例演示了变量在内存中地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span>   </span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"变量的地址: %x\n"</span>, &amp;a  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果为：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量的地址: <span class="number">20818a220</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>不同机器得到的地址是不一样的</p><blockquote><p>所以<code>指针</code>就是一个用来<code>存地址</code>的数据类型，感觉跟C语言的指针没啥差别。</p></blockquote><p>类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="keyword">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure><h3 id="如何使用指针"><a href="#如何使用指针" class="headerlink" title="如何使用指针"></a>如何使用指针</h3><ul><li>声明和定义指针</li><li>给指针赋值</li><li>引用指针</li></ul><p><code>在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</code>  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   <span class="selector-tag">var</span> <span class="selector-tag">a</span> int= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="selector-tag">var</span> ip *int        <span class="comment">/* 星号声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;<span class="selector-tag">a</span>  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"a 变量的地址是: %x\n"</span>, &amp;<span class="selector-tag">a</span>  )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">"ip 变量储存的指针地址: %x\n"</span>, ip )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">"*ip 变量的值: %d\n"</span>, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-空指针"><a href="#Go-空指针" class="headerlink" title="Go 空指针"></a>Go 空指针</h3><p>  当一个指针被定义后没有分配到任何变量时，它的值为 nil，所以nil指针也称空指针，在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值，指针变量通常缩写为<code>ptr</code><br>  实例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span>  ptr *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"ptr 的值为 : %x\n"</span>, ptr  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空指针判断：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">ptr</span> != <span class="keyword">nil</span>)     /* <span class="keyword">ptr</span> 不是空指针 */</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">ptr</span> == <span class="keyword">nil</span>)    /* <span class="keyword">ptr</span> 是空指针 */</span><br></pre></td></tr></table></figure><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><p>  JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率(百度百科解释)。<br>  所以JSON长下面这个样子：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"firstName"</span>: <span class="string">"json"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>  JSON 键值(Key-Value)对是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值,而且JSON里面还可以嵌套JSON对象，比如：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">"firstName"</span>: <span class="string">"json"</span>&#125;，</span><br><span class="line">&#123;<span class="string">"LastName"</span>: <span class="string">"json2"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><a href="https://godoc.org/github.com/tidwall/gjson" target="_blank" rel="noopener">JSON官方处理包</a></li><li><a href="https://github.com/tidwall/gjson" target="_blank" rel="noopener">github上的代码</a></li></ul><h3 id="gjson使用"><a href="#gjson使用" class="headerlink" title="gjson使用"></a>gjson使用</h3><ul><li>获取值  </li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">"github.com/tidwall/gjson"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = `&#123;<span class="string">"name"</span>:&#123;<span class="string">"first"</span>:<span class="string">"Janet"</span>,<span class="string">"last"</span>:<span class="string">"Prichard"</span>&#125;,<span class="string">"age"</span>:<span class="number">47</span>&#125;`</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span> &#123;</span></span><br><span class="line">value := gjson.Get(json, <span class="string">"name.last"</span>)</span><br><span class="line">println(value.<span class="built_in">String</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细的可以直接看github上的README。</p><p><strong><a href="https://www.tutorialspoint.com/online_golang_ide.php)" target="_blank" rel="noopener">Golang在线IDE</a></strong></p><p><strong>参考</strong>：</p><ol><li><a href="http://www.runoob.com/go/go-pointers.html" target="_blank" rel="noopener">菜鸟教程</a></li><li><a href="https://golang.org/#" target="_blank" rel="noopener">GoLang官网</a>（需自备梯子）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待续</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/03/29/Golang%E6%8C%87%E9%92%88%E4%B8%8EJSON/#disqus_thread</comments>
    </item>
    
    <item>
      <title>音频采样率与量化精度</title>
      <link>https://blog.jame-zhang.top/2018/03/29/%E9%9F%B3%E9%A2%91%E9%87%87%E6%A0%B7%E7%8E%87%E4%B8%8E%E9%87%8F%E5%8C%96%E7%B2%BE%E5%BA%A6/</link>
      <guid>https://blog.jame-zhang.top/2018/03/29/%E9%9F%B3%E9%A2%91%E9%87%87%E6%A0%B7%E7%8E%87%E4%B8%8E%E9%87%8F%E5%8C%96%E7%B2%BE%E5%BA%A6/</guid>
      <pubDate>Thu, 29 Mar 2018 05:36:32 GMT</pubDate>
      <description>
      
        &lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;/assets/hifi/hifi-logo.jpg&quot;&gt;&lt;/div&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div align="center"><img src="/assets/hifi/hifi-logo.jpg"></div><a id="more"></a>    <div id="aplayer-zbVUWdqa" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="460298181" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><h3 id="无损音乐跟一般音乐"><a href="#无损音乐跟一般音乐" class="headerlink" title="无损音乐跟一般音乐"></a>无损音乐跟一般音乐</h3><p>　　可能你会说，听个歌用得着那么挑剔吗？不都一样吗？没听过，你可能真的想象不出来高品质音乐跟一般的音乐的区别。我们都知道计算机是数字存储，也就是只能用0和1来存储处理，所以我们现在听的都是数字音乐。现实生活中的音乐是连续的，而数字音乐就是对连续的音乐进行不断采样，对连续的声波进行切割微分，然后记录保存。采样的频率越高，最终还原的效果也就越好，保真率越高。听无损音乐（高品质）音乐，每种乐器（每个频率：高音、低音、中音）的声音你都能很<code>清楚地辨别出来</code>，有<code>层次感</code>，而一般的音乐你听起来就像是<code>糊在一起一样</code>。</p><h3 id="什么是采样率和量化精度？16bit-44-1kHz、24bit-48kHz、24bit-192kHz-分别代表什么？"><a href="#什么是采样率和量化精度？16bit-44-1kHz、24bit-48kHz、24bit-192kHz-分别代表什么？" class="headerlink" title="什么是采样率和量化精度？16bit/44.1kHz、24bit/48kHz、24bit/192kHz 分别代表什么？"></a>什么是采样率和量化精度？16bit/44.1kHz、24bit/48kHz、24bit/192kHz 分别代表什么？</h3><ul><li><strong>采样率</strong><br>　　采样率实际上是指当将声音储存至计算机中，必须经过一个录音转换的过程，转换些什么呢？就是把声音这种模拟信号转成计算机可以辨识的数字信号，在转换过程中将声波的波形以微分方式切开成许多单位，再把每个切开的声波以一个数值来代表该单位的一个量，以此方式完成采样的工作，而在<code>单位时间内切开的数量</code>便是所谓的<code>采样频率</code>，说明白些，就是模拟转数字时每秒对声波采样的数量，像是CD音乐的标准采样频率为44.1KHz(指的就是在1s中对声音采样44100次，也就是对声音1秒的声音记录44100个点，用44100个点来表示1秒钟的声音)，这也是目前声卡与计算机作业间最常用的采样频率。<br>　　另外，在单位时间内采样的数量越多就会越接近原始的模拟信号，在将数字信号还原成模拟信号时也就越能接近真实的原始声音；相对的越高的采样率，资料的大小就越大，反之则越小，当然也就越不真实了。数字数据量的大小与声道数、采样率、音质分辨率有着密不可分的关系。<br>　　前面提到CD音乐的采样率为44.1KHz，而在计算机上的DVD音效则为48KHz (经声卡转换) ，一般的电台FM广播为32KHz，其它的音效则因不同的应用有不同的采样率，像是以Net Meeting之类的应用就不要使用高的采样率，否则在传递这些声音数据时会是一件十分痛苦的事。当然，目前比较盛行的蓝光的采样率就相当的高，达到了192kHz。而目前的声卡，绝大多数都可以支持44.1kHz、48kHz、96kHz，高端产品可支持192kHz甚至更高。</li><li><p><strong>量化精度</strong><br>　　声波在转为数字的过程中不是只有采样率会影响原始声音的完整性，另一个亦具有举足轻重的参数——量化精度，也是相当的重要。一般来说，<code>音质分辨率</code>就是大家常说的bit数。目前，绝大多数的声卡都已经可以支持24bit的量化精度。<br>　　那么，什么是量化精度呢？前面曾说明采样频率，它是针对每秒钟所采样的数量，而<code>量化精度</code>则是对于声波的<code>振幅</code>进行<code>切割</code>，形成类似阶梯的度量单位。所以，如果说采样频率是对声波水平进行的X轴切割，那么量化精度则是对Y轴的切割，切割的数量是以最大振幅切成2的n次方计算，n就是bit数。<br>　　举个例子，如果是8bit，那么在振幅方面的采样就有256阶，若是16bit，则振幅的计量单位便会成为65536阶，<code>越多的阶数就越能精确描述每个采样的振幅高度</code>。如此，也就越接近原始声波的“能量”，在还原的过程序也就越接近原始的声音了。<br>　　另外，bit的数目还决定了声波振幅的范围（即动态范围，最大音量与最小音量的差距）。如果这个位数越大，则能够表示的数值越大，描述波形更精确。每<code>一个Bit</code>的数据可以记录约<code>等于6dB</code>动态的信号。一般来说，16Bit可以提供最大96dB的动态范围（加高频颤动后只有92dB）。每增加一个Bit的量化精度，这个值就增加6dB。因此，我们可以推断出<code>20Bit</code>可以达到<code>120dB</code>的动态范围，而<code>24Bit</code>则可以提供高达<code>144dB</code>的动态范围。<br>　　那么，动态范围大了，会有什么好处呢？<code>动态范围</code>是指系统的<code>输出噪音功率</code>和<code>最大不失真音量功率</code>的比值，这个值越大，则系统可以承受很高的动态。比如1812序曲中的炮声，如果系统动态过小，高于动态范围的信号将被削波（Clipping, 高于0dB的溢出信号将被砍掉，会导致噼里啪啦的声音）。<br>　　16bit/44.1kHz、24bit/48kHz、24bit/192kHz这三种采样，16bit/44.1kHz是CD中音频的采样、24bit/48kHz是DVD中音频的采样（区分：不是DVD Audio），而24bit/192kHz是蓝光中音频的采样。</p><p><img src="/assets/hifi/sound-waves.jpg" alt=""></p></li></ul><h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>　　音质有时候也会用比特率表示，比特率(bits per second, <code>bps</code>)也叫码率，从英文的定义可以很清楚地知道，比特率指的就是每秒钟的位数（也叫比特数），比特是计算机的一个存储计量单位，就像是米、克等这样的常见单位，一个比特（位）就是 2<sup>1</sup>，能够表示 0 或 1，1字节(Byte) = 8 比特(bit), 1KB = 1028 Byte, 1MB = 1024 KB，1GB = 1024 MB，1TB = 1024 GB，1PB =1024 TB ······ ，根据比特率我们就可以算出音乐的存储大小，比如一首比特率为256kbps，4分钟的歌曲的存储大小为：(256 / 8) <em> 4 </em> 60 =7680 KB=7.68 MB,所以这首歌曲在计算机里的存储大小就是7.68 MB，如果是多通道的，则需要乘以通道数。</p><h3 id="声道"><a href="#声道" class="headerlink" title="声道"></a>声道</h3><p>　　声音的通道的数目。常见的单声道和立体声（双声道），现在发展到了四声环绕（四声道）和5.1声道。<br>　　耳机听立体声音乐，就会有左右声道的效果，知道音乐是在左边还是右边，类似于人眼的3D效果，左右配合起来才会有3D效果。 </p><h2 id="耳机"><a href="#耳机" class="headerlink" title="耳机"></a>耳机</h2><h3 id="耳机的参数"><a href="#耳机的参数" class="headerlink" title="耳机的参数"></a>耳机的参数</h3><blockquote><p>耳机参数只是一个参考指标，耳机的好坏跟参数有关，但是不是绝对相关。耳机的好坏还是要以适合自己的为准。</p></blockquote><p>　　俗话说“好马配好鞍”，有了高品质的音乐，自然得有一副好的耳机才能体验到细腻的聆听效果，比较讲究的话，还得要一个专门的播放器，专门的播放器利用硬件对音乐进行解码，一般电脑都是使用系统软件进行解码，不过有了好的音乐和好的耳机，已经感觉到区别了。<br>　　参见的耳机参数有：</p><ul><li>阻抗</li><li>灵敏度</li><li>频响范围  </li></ul><p>　　<strong>阻抗</strong>: 耳机是缩小版的扬声器，扬声器是利用电磁感应原理，使得振膜振动发声，电流通过导线，就会存在电阻，所以阻抗指的就是驱动耳机所存在的电阻，阻抗越大，耳机越不容易驱动，一般60欧姆以下的耳机，常见的手机可以直接推，<code>大阻抗</code>的耳机就需要<code>功率放大器</code>了。如果使用低阻耳机，一定先要把音量调低再插上耳机，再一点点把音量调上去，阻止耳机过载将耳机烧坏或是音圈变形错位造成破音，低阻抗的耳机一般比较容易推动，因此随身听、播放器等便携、省电的机器应选择低阻抗耳机，同时还要注意灵敏度要高。</p><p>　　<strong>灵敏度</strong>: 耳机灵敏度指的是指向耳机输入1毫瓦的功率时耳机所能发出的声压级（声压的单位是分贝，声压越大音量越大），所以一般灵敏度越高、阻抗越小，耳机越容易出声、越容易驱动，灵敏度可以简单地认为特定功率下的响度大小。</p><p>　　<strong>频率响应</strong>: 也叫频响，指的就是耳机所能播放的声音的频率范围。实际上，人耳所能听到的声音的范围是有限的，人耳能感受到的振动频率范围约为20-20000赫兹。随着年龄的增长，听觉上限会降低，强度范围为0.0002-1000 dyn/cm²（来自维基百科）。频响越大，声音层次感也越强。   </p><h3 id="耳机类型"><a href="#耳机类型" class="headerlink" title="耳机类型"></a>耳机类型</h3><p>　　不同的分类方法对应的耳机分类也是不一样的，这里主要讲的是根据耳机的发声结构的分类，耳机就是一对扬声器，传统的扬声器（我们常说的喇叭）一般是变化的电流流过线圈（下图中的6），线圈产生磁场，跟磁铁（下图中的5）异性相吸，同性相斥，带动振膜(下图中的2)振动发声，如果是线圈（下图中的6）振动，我们称作<code>动圈</code>，如果是磁铁（下图中的5）振动，我们称作是<code>动铁</code>。有多个单元的耳机就是有多个扬声器的耳机，单元越多，一般耳机的价格也越贵。动铁比较适合听电子乐、摇滚乐等，这些要求声音频率变化较快且变化较多的音乐，而动圈比较适合听古典乐。　　</p><div align="center"><img src="/assets/hifi/speaker.png"></div><p>　　还有一种分类方式就是根据佩戴的方法进行分类，可以分为<code>入耳式耳机</code>、<code>耳塞式</code>、<code>头戴式</code>等，我比较喜欢的是<code>入耳式</code>的耳机，隔音效果好，能够不被别人打扰，沉浸在自己的音乐里面，不过入耳式耳机也有缺点，就是听诊器效果严重，稍微碰一下耳机线，耳机听得很清楚，长时间使用入耳式耳机，对耳朵损害也比较严重。</p><h3 id="常见的耳机品牌"><a href="#常见的耳机品牌" class="headerlink" title="常见的耳机品牌"></a>常见的耳机品牌</h3><p>　　其实狗东或者天猫查询下HIFI耳机，然后排序下，就能知道常见的耳机都有哪些了，我了解的耳机有森海塞尔、索尼、舒尔、AKG、威士顿等，如果让我推荐的话，我还是会说“索尼大法好呀”，自己用xba-a2，已经用了两年了（索尼官网注册延保了一年），动圈结合，2个动铁，听电子乐最适合不过了。同价位的森海塞尔耳机跟xba-a2或者a3相比，感觉森海塞尔低音感严重丢失。</p><ul><li>B&amp;O、B&amp;W、拜亚动力、AKG、歌德、舒尔、威士顿（westone）、铁三角、天龙（音响）、BOSE、Sony</li><li>FITEAR(FITEAR 330、FITEAR 330P)</li></ul><p>参考： </p><ol><li><a href="https://blog.csdn.net/caoshangpa/article/details/51218597" target="_blank" rel="noopener">CSDN博客</a></li><li><a href="http://www.sonic-pro.com/technology/article/2014_1106_448.html" target="_blank" rel="noopener">介绍</a> </li></ol>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/03/29/%E9%9F%B3%E9%A2%91%E9%87%87%E6%A0%B7%E7%8E%87%E4%B8%8E%E9%87%8F%E5%8C%96%E7%B2%BE%E5%BA%A6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo博客优化</title>
      <link>https://blog.jame-zhang.top/2018/03/28/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/</link>
      <guid>https://blog.jame-zhang.top/2018/03/28/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Wed, 28 Mar 2018 02:50:52 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;更新下博客的优化的事项列表：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;博文插入背景音乐；  &lt;/li&gt;
&lt;li&gt;首页显示部分博文；  &lt;/li&gt;
&lt;li&gt;增加站点访问统计;  &lt;/li&gt;
&lt;li&gt;hexo多repo部署 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;博文更新截止时间：2018-04-01 22:39&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>更新下博客的优化的事项列表：  </p><ol><li>博文插入背景音乐；  </li><li>首页显示部分博文；  </li><li>增加站点访问统计;  </li><li>hexo多repo部署 </li></ol><p>博文更新截止时间：2018-04-01 22:39</p></blockquote><a id="more"></a>    <div id="aplayer-kyFOPfPc" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="531295576" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><h2 id="博文插入背景音乐"><a href="#博文插入背景音乐" class="headerlink" title="博文插入背景音乐"></a>博文插入背景音乐</h2><p>　　见另一篇博文<a href="https://jame-zhang.github.io/2018/03/18/Hexo%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/" target="_blank" rel="noopener">Hexo插入音乐播放器</a></p><h2 id="首页显示部分博文"><a href="#首页显示部分博文" class="headerlink" title="首页显示部分博文"></a>首页显示部分博文</h2><p>　　其实要在首页显示文章的一部分，只需要在想截断的地方插入<br>　　<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- More --&gt;</span></span><br></pre></td></tr></table></figure></p><p>　　然后在首页的文章就会显示<code>开头</code>到<code>&lt;!-- More --&gt;</code>的部分，当然有的主题也可以在_config.yml里设置，不过得主题支持。</p><h2 id="增加站点访问统计"><a href="#增加站点访问统计" class="headerlink" title="增加站点访问统计"></a>增加站点访问统计</h2><p>　　使用的插件为<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>，然后按照官网的教程，插入到对应的位置就好了。</p><h2 id="hexo多repo部署"><a href="#hexo多repo部署" class="headerlink" title="hexo多repo部署"></a>hexo多repo部署</h2><p>　　写完博客部署在多个站点和服务器上怎么办？目前我部署的站点有三个：</p><ol><li>Coding上的</li><li>github上</li><li>自己的服务器（使用rsync方法进行部署）<br>　　1和2需要安装git插件，3需要安装rsync插件，安装如下<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-rsync <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li></ol><p>然后配置<code>_config.yml</code>文件<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  - <span class="attribute">type</span>: git</span><br><span class="line">    <span class="attribute">repo</span>: </span><br><span class="line">      <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:jame-zhang/jame-zhang.github.io.git</span><br><span class="line">      <span class="attribute">coding</span>: git<span class="variable">@git</span>.coding.<span class="attribute">net</span>:EchoA/jame-zhang.coding.me.git</span><br><span class="line">    <span class="attribute">branch</span>: master</span><br><span class="line">  - <span class="attribute">type</span>: rsync</span><br><span class="line">    <span class="attribute">host</span>: <span class="number">192.168</span>.<span class="number">123.64</span></span><br><span class="line">    <span class="attribute">user</span>: root</span><br><span class="line">    <span class="attribute">root</span>: /usr/share/nginx/html/</span><br><span class="line">    <span class="attribute">port</span>: <span class="number">22</span></span><br></pre></td></tr></table></figure></p><p>最后敲部署命令<code>hexo d</code>就可以了<br><strong>注意：</strong>上面方法都需要提前配置好ssl证书登陆，才能有权限写文件。</p>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/03/28/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker介绍</title>
      <link>https://blog.jame-zhang.top/2018/03/23/Docker%E4%BB%8B%E7%BB%8D/</link>
      <guid>https://blog.jame-zhang.top/2018/03/23/Docker%E4%BB%8B%E7%BB%8D/</guid>
      <pubDate>Fri, 23 Mar 2018 02:13:28 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;什么是Docker&quot;&gt;&lt;a href=&quot;#什么是Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是Docker?&quot;&gt;&lt;/a&gt;什么是Docker?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;去年实习的时候，接触到Docker，过后也一直用，间隔了一段时间后，发现有些都给忘了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/Docker介绍/docker.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。而且Docker的操作命令跟Git命令类似。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker?"></a>什么是Docker?</h2><blockquote><p>去年实习的时候，接触到Docker，过后也一直用，间隔了一段时间后，发现有些都给忘了。</p></blockquote><p><img src="/assets/Docker介绍/docker.png" alt=""></p><p>  Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。而且Docker的操作命令跟Git命令类似。<br><a id="more"></a></p><blockquote><p><a href="https://www.docker.com" target="_blank" rel="noopener">Docker官网</a>、<a href="https://baike.baidu.com/item/Docker/13344470?fr=aladdin" target="_blank" rel="noopener">百度百科-Docker</a></p></blockquote>    <div id="aplayer-niIYYAxC" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="493705537" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><h2 id="Docker的用处"><a href="#Docker的用处" class="headerlink" title="Docker的用处"></a>Docker的用处</h2><p>  Docker其实就是一个虚拟化的容器，而且可以打包对应的环境和数据，比如你部署的某个服务器，包括<strong>各种各样的依赖环境和工具</strong>，有Git，MySql或MongoDB，nginx或者Caddy，Python3.5，OpenCV或者PIL等等，而且你也需要<strong>批量部署或者复制环境</strong>，比如需要把你的环境从A服务器迁移到B服务器，这个时候自己手动的去安装所有的环境会特别繁琐，但是如果使用Docker的话，只需要安装Docker程序，然后pull一下自己的Docker镜像，然后运行。</p><ul><li>安装Docker</li><li>Pull镜像</li><li>docker run image_id</li></ul><p><img src="/assets/Docker介绍/docker2.png" alt=""></p><p>  就像上图的右边部分，在底层(Kernel)之上，可以有很多容器(Container)，每个容器都安装了不同的环境和软件，复制了容器就相当于复制所有的环境和软件，环境复制和部署极为方便。</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>   安装教程请移步<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">官网</a><br>   <strong>注意</strong>：Docker版本分为社区版<code>Docker CE</code>和企业版<code>Docker EE</code>，个人安装的时候请选择CE版，CE版还分为稳定吧和测试版。</p><h3 id="验证Docker安装是否成功"><a href="#验证Docker安装是否成功" class="headerlink" title="验证Docker安装是否成功"></a>验证Docker安装是否成功</h3><p>运行命令:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker -v  <span class="comment">#查看安装的docker的版本</span></span><br><span class="line">docker -h  <span class="comment">#查看帮助</span></span><br><span class="line">docker <span class="built_in">version</span>  <span class="comment">#查看docker客户端和服务器版本情况</span></span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong><br>　　如果运行<code>docker version</code>的时候提示:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Client</span>:</span><br><span class="line"> <span class="attribute">Version</span>:      <span class="number">17.09</span>.<span class="number">1</span>-ce</span><br><span class="line"> API <span class="attribute">version</span>:  <span class="number">1.32</span></span><br><span class="line"> Go <span class="attribute">version</span>:   go1.<span class="number">8.3</span></span><br><span class="line"> Git <span class="attribute">commit</span>:   <span class="number">19</span>e2cf6</span><br><span class="line"> <span class="attribute">Built</span>:        Thu Dec  <span class="number">7</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">40</span> <span class="number">2017</span></span><br><span class="line"> OS/<span class="attribute">Arch</span>:      linux/amd64</span><br><span class="line">Cannot connect to the Docker daemon at <span class="attribute">unix</span>:<span class="comment">///var/run/docker.sock. Is the docker daemon running?</span></span><br></pre></td></tr></table></figure></p><p>说明docker服务还没开启，开启docker服务（不同系统软件运行命令可能不一样）：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker  <span class="comment">#我用的是centos7的系统</span></span><br></pre></td></tr></table></figure></p><p>重新运行<code>docker version</code>后，发现一切正常。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Client</span>:</span><br><span class="line"> <span class="attribute">Version</span>:      <span class="number">17.09</span>.<span class="number">1</span>-ce</span><br><span class="line"> API <span class="attribute">version</span>:  <span class="number">1.32</span></span><br><span class="line"> Go <span class="attribute">version</span>:   go1.<span class="number">8.3</span></span><br><span class="line"> Git <span class="attribute">commit</span>:   <span class="number">19</span>e2cf6</span><br><span class="line"> <span class="attribute">Built</span>:        Thu Dec  <span class="number">7</span> <span class="number">22</span>:<span class="number">23</span>:<span class="number">40</span> <span class="number">2017</span></span><br><span class="line"> OS/<span class="attribute">Arch</span>:      linux/amd64</span><br><span class="line"></span><br><span class="line"><span class="attribute">Server</span>:</span><br><span class="line"> <span class="attribute">Version</span>:      <span class="number">17.09</span>.<span class="number">1</span>-ce</span><br><span class="line"> API <span class="attribute">version</span>:  <span class="number">1.32</span> (minimum version <span class="number">1.12</span>)</span><br><span class="line"> Go <span class="attribute">version</span>:   go1.<span class="number">8.3</span></span><br><span class="line"> Git <span class="attribute">commit</span>:   <span class="number">19</span>e2cf6</span><br><span class="line"> <span class="attribute">Built</span>:        Thu Dec  <span class="number">7</span> <span class="number">22</span>:<span class="number">25</span>:<span class="number">03</span> <span class="number">2017</span></span><br><span class="line"> OS/<span class="attribute">Arch</span>:      linux/amd64</span><br><span class="line"> <span class="attribute">Experimental</span>: false</span><br></pre></td></tr></table></figure><h2 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h2><blockquote><p>参考书籍：<a href="http://product.dangdang.com/24194119.html" target="_blank" rel="noopener">Docker技术入门与实战</a></p></blockquote><h3 id="Docker包含哪些部分"><a href="#Docker包含哪些部分" class="headerlink" title="Docker包含哪些部分"></a>Docker包含哪些部分</h3><ul><li>DockerClient、DockerServer 客户端、服务器</li><li>Docker Image  镜像</li><li>Docker  仓库</li><li>DockerContainer  容器</li></ul><h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h4><p>   Docker的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。</p><h4 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h4><p>   Docker容器是由Docker镜像创建的运行实例。Docker容器类似虚拟机，可以支持的操作包括启动，停止，删除等。每个容器间是相互隔离的，容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。</p><h4 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h4><p>   Docker 仓库的概念跟Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。<br>   Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。<br>   仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p><p><img src="/assets/Docker介绍/dockerRepository.png" alt=""></p><h3 id="Docker容器与使用"><a href="#Docker容器与使用" class="headerlink" title="Docker容器与使用"></a>Docker容器与使用</h3><ul><li>下载镜像</li><li>根据镜像创建容器</li><li>运行容器</li></ul><blockquote><p>下面以搭建LAMP为例子：</p></blockquote><ul><li>docker命令查找镜像：<br>docker search 镜像名<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker search lamp</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/assets/Docker介绍/dockerSearch.png" alt=""></p><p>或者在<a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">DockerHub</a>上查找镜像：</p><p><img src="/assets/Docker介绍/dockerhub.png" alt=""></p><ul><li>下载镜像<br>docker pull 用户名(username)/镜像名(image name):镜像标签(tag)<ul><li>其中 用户名/镜像名是镜像仓库的名称（用来区分镜像），tag是镜像的标签（往往用来显示版本信息），通常情况下，描述一个镜像需要包括“名称+标签的信息”，如果省略标签信息，默认的是:latest</li></ul></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull greyltc/<span class="string">lamp:</span>latest</span><br></pre></td></tr></table></figure><p><img src="/assets/Docker介绍/dockerPull.png" alt=""></p><ul><li>下载过程中可以看出，镜像文件一般由若干层（layer）组成，上图中a3ed95caeb02这样的串是层的唯一id（256位的哈希值，确保唯一性），使用docker pull命令下载时会获取并输出镜像各层的信息。当不同的镜像包括相同的层是，本地仅存储层的一份内容，减少了需要的存储空间。</li><li>严格地讲，镜像的仓库名称中还应该添加仓库地址(即reigstry, 注册服务器)作为前缀，只是我们默认使用的是Docker Hub服务，该前缀可以省略。</li></ul><blockquote><p>例如，<code>docker pull ubuntu:14.04</code> 命令相当于<br><code>docker pull registry.hub.com/ubuntu:14.04</code> 命令，即从默认的注册服务器Docker Hub Registry中的ubuntu仓库下载标签为14.04的镜像。</p></blockquote><ul><li>国内docker注册服务器：registry.docker-cn.com，如果下载镜像遇到<code>net/http: TLS handshake timeout</code>时，请更改仓库地址，比如，下载报错信息如下：</li></ul><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root@lab-NF5270M3:/home/lab# docker pull yangxuan8282/kodexplorer</span></span><br><span class="line"><span class="attribute">Using default tag</span>: latest</span><br><span class="line"><span class="attribute">latest</span>: Pulling from yangxuan8282/kodexplorer</span><br><span class="line"><span class="attribute">81033e7c1d6a</span>: Pulling fs layer </span><br><span class="line"><span class="attribute">347280e4401e</span>: Pulling fs layer </span><br><span class="line"><span class="attribute">575b1e17046f</span>: Pulling fs layer </span><br><span class="line"><span class="attribute">b26c263d6f02</span>: Waiting </span><br><span class="line"><span class="attribute">f55d9e54ee0d</span>: Waiting </span><br><span class="line"><span class="attribute">a22a8dbb425c</span>: Waiting </span><br><span class="line"><span class="attribute">758733242058</span>: Waiting </span><br><span class="line"><span class="attribute">e0bd6fc2dfa9</span>: Waiting </span><br><span class="line"><span class="attribute">89aeba08ca46</span>: Waiting </span><br><span class="line"><span class="attribute">cb59dd8adaeb</span>: Waiting </span><br><span class="line"><span class="attribute">0d607511c911</span>: Waiting </span><br><span class="line"><span class="attribute">1563ddd0db9c</span>: Waiting </span><br><span class="line"><span class="attribute">error pulling image configuration</span>: Get https://dseasb33srnrn.cloudfront.net/registry-v2/docker/registry/v2/blobs/sha256/4a/4a4d9ae68feac9a584d13a5081fec2baea80e7b9dafb868218a0b3052b72f74d/data?Expires=1523229952&amp;Signature=Iltns2XwaWRvKCo9pah3-FgMGCQBBQ2216D7BUgjMIHc2dc7oZchTjXC8PzfhE5U2cV0mfko0FqARvwXtLBtGWDme5s7LW2kKN9qnmhhdC04iCo0DXJQFJlxXFxX2nxcfHfP~qw-P0F8eq1YkExfkOHWJAuvG9prlw2f1kGQK0Y_&amp;Key-Pair-Id=APKAJECH5M7VWIS5YZ6Q: net/http: TLS handshake timeout</span><br></pre></td></tr></table></figure><p>指定国内下载仓库，一切正常</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@lab-NF5270M3:/home/lab# docker pull registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span>/yangxuan8282/kodexplorer:php-amd64</span><br><span class="line">php-amd64: Pulling from yangxuan8282/kodexplorer</span><br><span class="line"><span class="number">81033</span>e7c1d6<span class="variable">a:</span> Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">347280</span>e4401e: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">575</span>b1e17046f: Pull <span class="built_in">complete</span> </span><br><span class="line">b26c263d6f02: Pull <span class="built_in">complete</span> </span><br><span class="line">f55d9e54ee0d: Pull <span class="built_in">complete</span> </span><br><span class="line">a22a8dbb425c: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">758733242058</span>: Pull <span class="built_in">complete</span> </span><br><span class="line">e0bd6fc2dfa9: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">795502</span>f6f7d5: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">5</span>d9f160c8bb7: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">142712</span>ee6bcf: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">05</span>b803eaeaee: Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:c7c2d60f41c7acd569e6958ae7e01b82408313b6052368631543f8cc594bbc84</span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span>/yangxuan8282/kodexplorer:php-amd64</span><br></pre></td></tr></table></figure><p><strong>最简单的解决方法</strong>：打开小火箭，然后搭个梯子就好了。  </p><ul><li>查看镜像<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/assets/Docker介绍/dockerImages.png" alt=""></p><ul><li>创建容器实例并运行镜像<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--name  "lamp" 2359</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="/assets/Docker介绍/dockerRun.png" alt=""></p><h3 id="Docker命令参考和查询"><a href="#Docker命令参考和查询" class="headerlink" title="Docker命令参考和查询"></a>Docker命令参考和查询</h3><ul><li><a href="https://docs.docker.com/v17.09/edge/engine/reference/commandline/docker/" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker从入门到实践 - Gitbook</a></li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/03/23/Docker%E4%BB%8B%E7%BB%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ssh使用ssl中的rsa证书进行登录</title>
      <link>https://blog.jame-zhang.top/2018/03/22/ssh%E4%BD%BF%E7%94%A8ssl%E4%B8%AD%E7%9A%84rsa%E8%AF%81%E4%B9%A6%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95/</link>
      <guid>https://blog.jame-zhang.top/2018/03/22/ssh%E4%BD%BF%E7%94%A8ssl%E4%B8%AD%E7%9A%84rsa%E8%AF%81%E4%B9%A6%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95/</guid>
      <pubDate>Thu, 22 Mar 2018 02:35:28 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;之前用谷歌虚拟主机搭了一个小机场，但是只当机场用，有点浪费，所以最近觉得应该把这个服务器用起来，ssh连接的时候遇到点小问题，所以记录下来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/ssh/ssh-big.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>之前用谷歌虚拟主机搭了一个小机场，但是只当机场用，有点浪费，所以最近觉得应该把这个服务器用起来，ssh连接的时候遇到点小问题，所以记录下来</p></blockquote><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><img src="/assets/ssh/ssh-big.png" alt=""><br><a id="more"></a><br><strong>什么是SSH?</strong><br>如果你经常玩linux，经常需要远程连接服务器，那么对于ssh应该很熟，关于具体原理可以参考另外一篇博文<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">阮一峰的ssh原理</a>，我觉得他讲的很通俗易懂。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><strong>SSH一直连接不上</strong><br>一直提示<code>Pemission Denied(publickey)</code>，可是我明明已经把rsa的公钥放到~/.ssh/authorized_keys 里面了，也把/etc/sshd_config的配置文件也配置了，但是最终还是失败，最后发现问题所在，就是允许密码登陆的地方给遗漏了，配置文件如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Package generated configuration file</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See the sshd_config(5) manpage <span class="keyword">for</span> details</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> What ports, IPs and protocols we listen <span class="keyword">for</span></span></span><br><span class="line">Port 22</span><br><span class="line"><span class="meta">#</span><span class="bash"> Use these options to restrict <span class="built_in">which</span> interfaces/protocols sshd will <span class="built_in">bind</span> to</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ListenAddress ::</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ListenAddress 0.0.0.0</span></span><br><span class="line">Protocol 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> HostKeys <span class="keyword">for</span> protocol version 2</span></span><br><span class="line">HostKey /etc/ssh/ssh_host_rsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_dsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ed25519_key</span><br><span class="line"><span class="meta">#</span><span class="bash">Privilege Separation is turned on <span class="keyword">for</span> security</span></span><br><span class="line">UsePrivilegeSeparation yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lifetime and size of ephemeral version 1 server key</span></span><br><span class="line">KeyRegenerationInterval 3600</span><br><span class="line">ServerKeyBits 1024</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Logging</span></span><br><span class="line">SyslogFacility AUTH</span><br><span class="line">LogLevel INFO</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Authentication:</span></span><br><span class="line">LoginGraceTime 120</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">StrictModes yes</span><br><span class="line"></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile%h/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Don<span class="string">'t read the user'</span>s ~/.rhosts and ~/.shosts files</span></span><br><span class="line">IgnoreRhosts yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> For this to work you will also need host keys <span class="keyword">in</span> /etc/ssh_known_hosts</span></span><br><span class="line">RhostsRSAAuthentication no</span><br><span class="line"><span class="meta">#</span><span class="bash"> similar <span class="keyword">for</span> protocol version 2</span></span><br><span class="line">HostbasedAuthentication no</span><br><span class="line"><span class="meta">#</span><span class="bash"> Uncomment <span class="keyword">if</span> you don<span class="string">'t trust ~/.ssh/known_hosts for RhostsRSAAuthentication</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">IgnoreUserKnownHosts yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> To <span class="built_in">enable</span> empty passwords, change to yes (NOT RECOMMENDED)</span></span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Change to yes to <span class="built_in">enable</span> challenge-response passwords (beware issues with</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> some PAM modules and threads)</span></span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Change to no to <span class="built_in">disable</span> tunnelled clear text passwords</span></span><br><span class="line">PasswordAuthentication no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Kerberos options</span></span><br><span class="line"><span class="meta">#</span><span class="bash">KerberosAuthentication no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">KerberosGetAFSToken no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">KerberosOrLocalPasswd yes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">KerberosTicketCleanup yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> GSSAPI options</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPIAuthentication no</span></span><br><span class="line"><span class="meta">#</span><span class="bash">GSSAPICleanupCredentials yes</span></span><br><span class="line"></span><br><span class="line">X11Forwarding yes</span><br><span class="line">X11DisplayOffset 10</span><br><span class="line">PrintMotd no</span><br><span class="line">PrintLastLog yes</span><br><span class="line">TCPKeepAlive yes</span><br><span class="line"><span class="meta">#</span><span class="bash">UseLogin no</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">MaxStartups 10:30:60</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Banner /etc/issue.net</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Allow client to pass locale environment variables</span></span><br><span class="line">AcceptEnv LANG LC_*</span><br><span class="line"></span><br><span class="line">Subsystem sftp /usr/lib/openssh/sftp-server</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set this to <span class="string">'yes'</span> to <span class="built_in">enable</span> PAM authentication, account processing,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and session processing. If this is enabled, PAM authentication will</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> be allowed through the ChallengeResponseAuthentication and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PasswordAuthentication.  Depending on your PAM configuration,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PAM authentication via ChallengeResponseAuthentication may bypass</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the setting of <span class="string">"PermitRootLogin without-password"</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you just want the PAM account and session checks to run without</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> PAM authentication, <span class="keyword">then</span> <span class="built_in">enable</span> this but <span class="built_in">set</span> PasswordAuthentication</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and ChallengeResponseAuthentication to <span class="string">'no'</span>.</span></span><br><span class="line">UsePAM yes</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Google Compute Engine <span class="built_in">times</span> out connections after 10 minutes of inactivity.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keep alive ssh connections by sending a packet every 2 minutes.</span></span><br><span class="line">ClientAliveInterval 120</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Prevent reverse DNS lookups.</span></span><br><span class="line">UseDNS no</span><br></pre></td></tr></table></figure></p><p>ssh的配置文件存放在<code>/etc/ssh/</code>下，<code>sshd_config</code>是ssh服务器(也就是个人主机连接你的服务器，你对个人主机的限制)的配置文件，<code>ssh_config</code>是ssh客户端的配置文件，需要修改sshd_config，这样我才能实现远程连接到谷歌的这台主机，修改的地方如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PermitRootLogin</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">RSAAuthentication</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">PubkeyAuthentication</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">AuthorizedKeysFile</span><span class="string">%h/.ssh/authorized_keys</span></span><br><span class="line"><span class="string">PasswordAuthentication</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure></p><p>把上面几处的值改成yes，然后把注释符号<code>#</code>去除，然后可以了。</p><h2 id="添加本机的rsa公钥到主机上，实现无密码登陆"><a href="#添加本机的rsa公钥到主机上，实现无密码登陆" class="headerlink" title="添加本机的rsa公钥到主机上，实现无密码登陆"></a>添加本机的rsa公钥到主机上，实现无密码登陆</h2><p>生成秘钥命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></p><p>可以一直回车，对于私钥可以设置一个密码，进行加密，防止泄露<br>　　查看本机的rsa公钥:<code>cat ~/ssh/id_rsa.pub</code>，然后复制，粘贴到远程主机的<code>~/.ssh/authorized_keys</code>里面就可以了，最后实现无密码的登陆。</p><p><img src="/assets/ssh/ssh.gif" alt=""></p><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">ssh原理</a></p>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/03/22/ssh%E4%BD%BF%E7%94%A8ssl%E4%B8%AD%E7%9A%84rsa%E8%AF%81%E4%B9%A6%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo插入音乐播放器</title>
      <link>https://blog.jame-zhang.top/2018/03/18/Hexo%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</link>
      <guid>https://blog.jame-zhang.top/2018/03/18/Hexo%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</guid>
      <pubDate>Sun, 18 Mar 2018 04:52:47 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;博客搭完，总想着继续优化，所以SEO还没弄，就觉得插入背景音乐得提前配置好，不然多单调，生活不能缺少音乐。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p>博客搭完，总想着继续优化，所以SEO还没弄，就觉得插入背景音乐得提前配置好，不然多单调，生活不能缺少音乐。</p></blockquote><a id="more"></a><p>下面是我个人网易云播放列表，先看下效果:<br>    <div id="aplayer-VALeFWyC" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="157600392" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>其实最重要的就是hexo的一个音乐播放插件：<a href="https://hexo.io/plugins/index.html" target="_blank" rel="noopener"><code>Aplyer</code></a>, 可以在hexo的官网的插件里找到这个插件，这个插件把国内常用的音乐平台都考虑了，基本都支持的，具体用法可以看托管在github上的<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">Readme</a>文档。</p><h2 id="安装-hexo-tag-aplayer"><a href="#安装-hexo-tag-aplayer" class="headerlink" title="安装 hexo-tag-aplayer"></a>安装 hexo-tag-aplayer</h2><p>使用npm进行包安装：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-tag-aplayer</span></span><br></pre></td></tr></table></figure></p><h2 id="使用Aplayer播放单曲音乐"><a href="#使用Aplayer播放单曲音乐" class="headerlink" title="使用Aplayer播放单曲音乐"></a>使用Aplayer播放单曲音乐</h2><p>安装完之后，在你的博文Markdown文档中插入下面代码，就可以播放了<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span><br></pre></td></tr></table></figure></p><p>比如：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">%</span> aplayer <span class="string">"Final Song (OutaMatic Remix)"</span> <span class="string">"OutaMatic / MØ"</span> <span class="string">"http://m10.music.126.net/20180319155625/84285920851537de9043c7be559eca1e/ymusic/4ba1/ca75/1b0f/2d7f58612c6d318436c5be55a0eb78dd.mp3"</span> <span class="string">"http://p1.music.126.net/Exmbjlfrsksz0K66L_Ljnw==/1412872456535765.jpg"</span>, <span class="string">"autoplay"</span> <span class="meta">%</span>&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>上面单曲的内容没有显示出来，是因为一个文档里面不支持包含metingJS、Aplayer同时播放，而且根据我自己的测试，是优先播放MetingJS的插件，也就是专辑播放的优先级大于单曲播放，但是可以使用metingJS进行单曲播放，比如：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"427614378"</span> <span class="string">"netease"</span> <span class="string">"song"</span> %&#125;</span><br></pre></td></tr></table></figure>    <div id="aplayer-MlnreEYi" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="427614378" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div><p>上面的内容都是需要自己填的，包括图片地址，mp3地址(可以是本地，也可以是放在别的服务器上的url) ，具体怎么获取，我是利用chrome的开发工具查看资源的地址，后面再用一篇博文专门介绍下chrome的开发工具的使用。</p><p><img src="/assets/Hexo插入音乐播放器/chrome.png" alt=""></p><h2 id="使用MeingJS播放专辑和列表"><a href="#使用MeingJS播放专辑和列表" class="headerlink" title="使用MeingJS播放专辑和列表"></a>使用MeingJS播放专辑和列表</h2><p>在配置文件<code>_config.yml</code>启用MeingJS<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">  meting:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>然后插入代码<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- Simple example (id, server, type)  --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">meting</span> "60198" "netease" "playlist" %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- Advanced example --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">meting</span> "60198" "netease" "playlist" "autoplay" "mutex:false" "listmaxheight:340px" "preload:none" "theme:#ad7a86"%&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><p>比如，插入我个人网易云播放列表：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% meting <span class="string">"157600392"</span> <span class="string">"netease"</span> <span class="string">"playlist"</span> %&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br>    <div id="aplayer-CBsZLjNv" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="157600392" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div></p><h2 id="关于id"><a href="#关于id" class="headerlink" title="关于id"></a>关于id</h2><p>网易云打开一首歌，或者一个列表，在浏览器的地址栏就可以看到id号<br><img src="/assets/Hexo插入音乐播放器/music.png" alt=""></p><p>下面是我参考的几篇文章：</p><ul><li><a href="https://diygod.me/best-players-in-hexo/" target="_blank" rel="noopener">第一篇</a></li><li><a href="https://www.fghrsh.net/post/17.html" target="_blank" rel="noopener">第二篇</a></li><li><a href="http://blog.csdn.net/u013384788/article/details/74079890" target="_blank" rel="noopener">第三篇</a></li><li><a href="https://i-meto.com/ghost-aplayer/" target="_blank" rel="noopener">第四篇</a></li></ul>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/03/18/Hexo%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Raspberry Pi 3玩机日志</title>
      <link>https://blog.jame-zhang.top/2018/03/15/Raspberry-Pi-3%E7%8E%A9%E6%9C%BA%E6%97%A5%E5%BF%97/</link>
      <guid>https://blog.jame-zhang.top/2018/03/15/Raspberry-Pi-3%E7%8E%A9%E6%9C%BA%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Thu, 15 Mar 2018 09:22:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近弄了一批树莓派，需要刷系统和配置，先上几张图，如下：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/Raspberry-Pi-3玩机日志/F1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最近弄了一批树莓派，需要刷系统和配置，先上几张图，如下：  </p><p><img src="/assets/Raspberry-Pi-3玩机日志/F1.jpg" alt=""><br><a id="more"></a><br><img src="/assets/Raspberry-Pi-3玩机日志/F2.jpg" alt="">  </p><p><img src="/assets/Raspberry-Pi-3玩机日志/F3.jpg" alt=""></p><p>总共10台机子，基本可以用来搭个小规模的集群了。</p><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><ul><li><strong>什么是树莓派呢？</strong></li></ul><p>简单的说，树莓派就是一个简单的linux计算机，只是性能没有个人PC那么强大，如果不过性能基本够当一台个人服务器了，不同型号的树莓派配置不同，具体可到官网查看所有型号和配置列表</p><blockquote><p> 更详细介绍请移步<a href="(https://baike.baidu.com/item/%E6%A0%91%E8%8E%93%E6%B4%BE/80427?fr=aladdin)">百度百科</a>，<a href="https://www.raspberrypi.org/" target="_blank" rel="noopener">Raspberry官网</a></p></blockquote><p><strong>树莓派3 B型的配置</strong>:  </p><blockquote><p>数据来自<a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/" target="_blank" rel="noopener">官网</a> </p></blockquote><ul><li>1.2GHz 四核 Broadcom BCM283764位 处理器</li><li>1GB RAM</li><li>板载BCM43143 WiFi和板载低功耗蓝牙(BLE)</li><li>40针扩展GPIO</li><li>4个USB2.0端口</li><li>4路立体声输出和复合视频端口</li><li>全尺寸HDMI和RCA视频输出</li><li>CSI照相机端口用于连接树莓派照相机</li><li>DSI显示端口用于连接树莓派触屏显示器</li><li>Micro SD端口,用于下载操作系统以及存储数据</li></ul><p><img src="/assets/Raspberry-Pi-3玩机日志/circuit.png" alt="" title="图片来自某宝"></p><ul><li><p><strong>树莓派有什么功能？</strong></p><ol><li><p>自带<strong>无线网卡</strong></p></li><li><p>有<strong>蓝牙4.1</strong></p></li><li><p>有<strong>HDMI高清输出</strong></p></li><li><p>有<strong>网线接口</strong></p></li><li><p>4x <strong>usb2.0 接口 </strong> </p></li></ol></li></ul><p>所以树莓派就是<strong>一台电脑</strong>，有无线，有蓝牙，有HDMI输出，有网线接口以及USB接口，麻雀虽小五脏俱全，处理器平台为ARM，嵌入式设备，可以刷的系统有很多（Ubuntu、Raspbian、PINET等），在系统之上安装和开发的应用就更不用说了，很多微型PC就可以组建一个廉价的集群了。</p><h2 id="树莓派组装"><a href="#树莓派组装" class="headerlink" title="树莓派组装"></a>树莓派组装</h2><p>组装其实很简单，唯一要注意的就是小风扇是散热用的，所以风应该是往外吹才对，安装的时候要注意下正负极以及安装的方向，正确的安装方法：风扇标签朝外，然后红色的接5v正极，黑色的接GND</p><p><img src="/assets/Raspberry-Pi-3玩机日志/pinRaspberryPi3.jpg" alt=""></p><p><img src="/assets/Raspberry-Pi-3玩机日志/P1.jpg" alt=""></p><p><img src="/assets/Raspberry-Pi-3玩机日志/P2.jpg" alt=""></p><p><img src="/assets/Raspberry-Pi-3玩机日志/blackAndWhite.jpg" alt=""></p><p>左右只是盒子不一样，因为是在两家不同的店买的。</p><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p><code>官网</code>有十分详细的教程，请移步<a href="(https://www.raspberrypi.org/documentation/installation/installing-images/README.md)">官网刷机教程</a>，具体步骤如下：</p><ol><li>选择并下载系统</li><li>下载和安装刷系统软件Etcher</li><li>然后将内存卡接到电脑上，打开Etcher软件，选择镜像，进行刷机</li></ol><p>刷完将内存卡安装回机器上就好了。</p><p><img src="/assets/Raspberry-Pi-3玩机日志/prograss1.png" alt=""></p><p><img src="/assets/Raspberry-Pi-3玩机日志/prograss2.png" alt=""></p><p><img src="/assets/Raspberry-Pi-3玩机日志/prograss3.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：刷完系统后直接在内存卡根目录创建一个小写的ssh空白文件，这样能保证开机自动打开ssh，这样我们就能够在不需要显示器的情况下通过ssh进行连接和配置</span><br></pre></td></tr></table></figure><p><img src="/assets/Raspberry-Pi-3玩机日志/prograss4.png" alt=""></p><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><p>所需材料：</p><ul><li>刚刷完系统的树莓派</li><li>网线</li><li>电脑</li><li>路由器</li></ul><p>将树莓派用网线连接到路由器上，然后进路由器查看下树莓派所获得的IP，打开SSH连接工具输入连接命令</p><p>SSH工具：MAC版：直接终端，Windows版：<a href="http://ultra.pr.erau.edu/~jaffem/tutorial/SSH_secure_shell_client.htm" target="_blank" rel="noopener">SSH Secure Shell Client</a>、<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank" rel="noopener">Putty</a></p><ul><li>将网线和电源接到树莓派上面，树莓派开始工作，可以看到绿灯亮一会，然后开始闪，绿灯亮着或者在闪说明在工作</li></ul><p><img src="/assets/Raspberry-Pi-3玩机日志/workOn.gif" alt=""></p><ul><li>​查看路由器的IP</li></ul><p><img src="/assets/Raspberry-Pi-3玩机日志/workOn1.png" alt=""></p><ul><li>打开ssh连接工具，输入连接命令<code>初始用户名：pi，密码：raspberry</code></li></ul><p><img src="/assets/Raspberry-Pi-3玩机日志/workOn2.png" alt=""></p><h3 id="修改用户名和密码"><a href="#修改用户名和密码" class="headerlink" title="修改用户名和密码"></a>修改用户名和密码</h3><p><strong>修改pi用户密码</strong>：命令<code>sudo passwd pi</code>，输入两次密码  </p><p><strong>修改root用户密码</strong>：命令<code>sudo passwd root</code>，输入两次密码</p><p>OK，尽情的玩耍吧，这个就是你的Linux主机了，Have Fun!!</p>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/03/15/Raspberry-Pi-3%E7%8E%A9%E6%9C%BA%E6%97%A5%E5%BF%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Markdown语法</title>
      <link>https://blog.jame-zhang.top/2018/03/10/Markdown%E8%AF%AD%E6%B3%95/</link>
      <guid>https://blog.jame-zhang.top/2018/03/10/Markdown%E8%AF%AD%E6%B3%95/</guid>
      <pubDate>Sat, 10 Mar 2018 12:38:19 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Markdwon语法学习&quot;&gt;&lt;a href=&quot;#Markdwon语法学习&quot; class=&quot;headerlink&quot; title=&quot;Markdwon语法学习&quot;&gt;&lt;/a&gt;Markdwon语法学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  去年就接触到Markdown，也时常用，不过也只有常用的语法才记得，这几天突然想把博客搭建好，之前弄了一次，因为没有记录的想法最后也夭折了，现在重新搭建好之后，也就想着把Markdown重新系统的学一遍，所以上网找了下资料，整理了下，把自己学到的和别人没考虑到的都整理进来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网上的资料挺多的，看起来也是杂七杂八，都是需要经过自己的处理加工，自己理解之后才能变成自己的，从信息到知识。&lt;br&gt;主要的参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;直接谷歌搜索&lt;/code&gt;的&lt;a href=&quot;https://www.markdowntutorial.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown tutorial&lt;/a&gt;，排名第一的那个连接，有github的标志，而且看网址，应该就是Markdown官方的教程   &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Markdwon语法学习"><a href="#Markdwon语法学习" class="headerlink" title="Markdwon语法学习"></a>Markdwon语法学习</h1><blockquote><p>  去年就接触到Markdown，也时常用，不过也只有常用的语法才记得，这几天突然想把博客搭建好，之前弄了一次，因为没有记录的想法最后也夭折了，现在重新搭建好之后，也就想着把Markdown重新系统的学一遍，所以上网找了下资料，整理了下，把自己学到的和别人没考虑到的都整理进来。</p></blockquote><p>网上的资料挺多的，看起来也是杂七杂八，都是需要经过自己的处理加工，自己理解之后才能变成自己的，从信息到知识。<br>主要的参考资料：</p><ul><li><p><code>直接谷歌搜索</code>的<a href="https://www.markdowntutorial.com/" target="_blank" rel="noopener">Markdown tutorial</a>，排名第一的那个连接，有github的标志，而且看网址，应该就是Markdown官方的教程   </p><a id="more"></a><p><img src="/assets/Markdown语法/googleSearch.png" alt="" title="谷歌直接搜索markdown tutorial"><br><img src="/assets/Markdown语法/markdownTutorial.png" alt="" title="谷歌直接搜索markdown tutorial">  </p></li><li><p>另外一个就是在<code>别的博客看到</code>，然后人家标了原作者，所以我就直接跳到<a href="https://github.com/guodongxiaren/README" target="_blank" rel="noopener">GITHUB</a>上了</p></li><li><p>最后一个是一个台湾人整理的，有进行了繁体转简体工作，<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md" target="_blank" rel="noopener">繁体版</a>, <a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">简体版</a></p></li></ul><hr><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><blockquote><p>下面就把我自己整理的语法笔记记录下</p></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>   <code>#</code>表示的就是标题文字，<code>#</code>的个数表示的就是标题的级别，具体语法和效果如下：</p><p><img src="/assets/Markdown语法/title.png" alt=""></p><p><code>注意</code>：二级标题默认会自动添加横线，所以如果加了横线,则你的上一行的文字默认为二级标题，即<code>二级标题等同于换行加横线(-----)，必须用-，别的方式的横线失效</code>如：</p><p><img src="/assets/Markdown语法/secondTitle.png" alt=""></p><h2 id="粗体、斜体、删除线"><a href="#粗体、斜体、删除线" class="headerlink" title="粗体、斜体、删除线"></a>粗体、斜体、删除线</h2><table><thead><tr><th>语法</th><th>效果</th></tr></thead><tbody><tr><td><code>*斜体1*</code></td><td><em>斜体1</em></td></tr><tr><td><code>_斜体2_</code></td><td><em>斜体2</em></td></tr><tr><td><code>**粗体1**</code></td><td><strong>粗体1</strong></td></tr><tr><td><code>__粗体2__</code></td><td><strong>粗体2</strong></td></tr><tr><td><code>这是一个 ~~删除线~~</code></td><td>这是一个 <del>删除线</del></td></tr><tr><td><code>***斜粗体1***</code></td><td><strong><em>斜粗体1</em></strong></td></tr><tr><td><code>___斜粗体2___</code></td><td><strong><em>斜粗体2</em></strong></td></tr><tr><td><code>***~~斜粗体删除线1~~***</code></td><td><strong><em><del>斜粗体删除线1</del></em></strong></td></tr><tr><td><code>~~***斜粗体删除线2***~~</code></td><td><del><strong><em>斜粗体删除线2</em></strong></del></td></tr></tbody></table><p>斜体、粗体、删除线可混合使用</p><h2 id="段首空格"><a href="#段首空格" class="headerlink" title="段首空格"></a>段首空格</h2><p>在编辑的时候，需要段首缩进，具体的做法就是，在开头输入全角的空格，半角的空格输入是无效的，快捷键可以是<code>Mac版：alt+space</code>，<code>Windows版：ctrl+space</code></p><h2 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h2><p>***、—、___可以显示横线效果</p><hr><hr><hr><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>Markdown换行有两种方法，一种是在上一行末尾加入两个或以上空格（软换行）<br>第二种是需要换行的文本前后各留一个空行<br><code>注意: 硬换行（前后各空一行）的间距比软换行（前一行末尾添加两个或以上空格）的大</code><br><img src="/assets/Markdown语法/line.png" alt=""></p><h2 id="强调文本段落"><a href="#强调文本段落" class="headerlink" title="强调文本段落"></a>强调文本段落</h2><h4 id="语法1"><a href="#语法1" class="headerlink" title="语法1"></a>语法1</h4><p>在文本开头前空一行，然后加4个空格，一个段落的文本开头都需要加入4个空格</p><pre><code>Hello你好你好</code></pre><h4 id="语法2"><a href="#语法2" class="headerlink" title="语法2"></a>语法2</h4><p>使用一对各三个的反引号：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">你好</span><br><span class="line">你好</span><br></pre></td></tr></table></figure></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用在开头用大于号<code>&gt;</code>表示，&gt;与文本直接<code>需要有空格</code>且<code>&gt;需要在行首，也就是另起一行</code>，如：’&gt; 这是一句引用’，效果如下：</p><blockquote><p>这是一句引用</p></blockquote><p>如果是一段话，则在每行话的行首都需要有<code>&gt;</code>(不同的Markdown编辑器有差异)，<code>引用段内的换行</code>语法与上面<a href="#换行">换行</a>的一致，如：</p><blockquote><p>这是引用段落的第一行<br>这是第二行<br>这是第三行</p></blockquote><h3 id="块引用有多级结构"><a href="#块引用有多级结构" class="headerlink" title="块引用有多级结构"></a>块引用有多级结构</h3><p><code>&gt;</code>大于号的数量表示的就是级别，与标题的<code>#</code>一致</p><blockquote><p>数据结构</p><blockquote><p>树</p><blockquote><p>二叉树</p><blockquote><p>平衡二叉树</p><blockquote><p>满二叉树</p></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><hr><p>基本格式：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt</span>](<span class="link">URL title</span>)</span><br></pre></td></tr></table></figure></p><p>alt和title即对应HTML中的alt和title属性（都可省略）：</p><ul><li>alt表示图片显示失败时的替换文本</li><li>title表示鼠标悬停在图片时的显示文本（注意这里要加引号）</li></ul><p>URL即图片的url地址，如果引用本仓库中的图片，直接使用<strong>相对路径</strong>就可了，如果引用其他github仓库中的图片要注意格式，即：<code>仓库地址/raw/分支名/图片路径</code>，如：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/guodongxiaren/</span>ImageCache<span class="regexp">/raw/m</span>aster<span class="regexp">/Logo/</span>foryou.gif</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>#</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>1</td><td><code>![baidu](http://www.baidu.com/img/bdlogo.gif &quot;百度logo&quot;)</code></td><td><img src="http://www.baidu.com/img/bdlogo.gif" alt="baidu" title="百度logo"></td></tr><tr><td>2</td><td><code>![][foryou]</code></td><td><img src="https://github.com/guodongxiaren/ImageCache/raw/master/Logo/foryou.gif" alt=""></td></tr></tbody></table><p>注意例2的写法使用了<strong>URL标识符</strong>的形式，在<a href="#链接">链接</a>一节有介绍。</p><blockquote><p>在文末有foryou的定义：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[foryou]:https:<span class="regexp">//gi</span>thub.com<span class="regexp">/guodongxiaren/</span>ImageCache<span class="regexp">/raw/m</span>aster<span class="regexp">/Logo/</span>foryou.gif</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="图片居中"><a href="#图片居中" class="headerlink" title="图片居中"></a>图片居中</h3><p>  要想让图片居中，可以利用html的div标签，具体如下：<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片地址"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以加入width、heigh控制大小比例。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="链接外部URL"><a href="#链接外部URL" class="headerlink" title="链接外部URL"></a>链接外部URL</h3><table><thead><tr><th>#</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>1</td><td><code>[百度](http://www.baidu.com &quot;悬停显示&quot;)</code></td><td><a href="http://www.baidu.com" title="悬停显示" target="_blank" rel="noopener">百度</a></td></tr><tr><td>2</td><td><code>[知乎][zhihu]</code></td><td><a href="http://www.zhihu.com" target="_blank" rel="noopener">知乎</a></td></tr></tbody></table><p>语法2由两部分组成：</p><ul><li>第一部分使用两个中括号，[ ]里的标识符（本例中zhihu），可以是数字，字母等的组合，标识符上下对应就行了（<strong>姑且称之为URL标识符</strong>）</li><li>第二部分标记实际URL。</li></ul><blockquote><p>使用URL标识符能达到复用的目的，一般把全文所有的URL标识符统一放在文章末尾，这样看起来比较干净。</p><blockquote><p>URL标识符是我起的名字，不知道是否准确。囧。。</p></blockquote></blockquote><h3 id="链接本仓库里的URL"><a href="#链接本仓库里的URL" class="headerlink" title="链接本仓库里的URL"></a>链接本仓库里的URL</h3><table><thead><tr><th>语法</th><th>效果</th></tr></thead><tbody><tr><td><code>[我的简介](/example/profile.md)</code></td><td><a href="/example/profile.md">我的简介</a></td></tr><tr><td><code>[Book](./Book)</code></td><td><a href="/Book">Book</a></td></tr></tbody></table><h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><p>给图片加链接的本质是混合图片显示语法和普通的链接语法。普通的链接中[ ]内部是链接要显示的文本，而图片链接[ ]里面则是要显示的图片。<br>直接混合两种语法当然可以，但是十分啰嗦，为此我们可以使用URL标识符的形式。</p><table><thead><tr><th>#</th><th>语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td>1</td><td><code>[![weibo-logo]](http://weibo.com/linpiaochen)</code></td><td style="text-align:center"><a href="http://weibo.com/linpiaochen" target="_blank" rel="noopener">![weibo-logo]</a></td></tr><tr><td>2</td><td><code>[![](/img/zhihu.png &quot;我的知乎，欢迎关注&quot;)][zhihu]</code></td><td style="text-align:center"><a href="http://www.zhihu.com" target="_blank" rel="noopener"><img src="/img/zhihu.png" alt="" title="我的知乎，欢迎关注"></a></td></tr><tr><td>3</td><td><code>[![csdn-logo]][csdn]</code></td><td style="text-align:center">[![csdn-logo]][csdn]</td></tr></tbody></table><p>因为图片本身和链接本身都支持URL标识符的形式，所以图片链接也可以很简洁（见例3）。<br>注意，此时鼠标悬停时显示的文字是图片的title，而非链接本身的title了。</p><blockquote><p>本文URL标识符都放置于文末</p></blockquote><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>其实呢，每一个标题都是一个锚点，和HTML的锚点（<code>#</code>）类似，比如我们 </p><table><thead><tr><th>语法</th><th>效果</th></tr></thead><tbody><tr><td><code>[回到顶部](#readme)</code></td><td><a href="#readme">回到顶部</a></td></tr></tbody></table><p>不过要注意，标题中的英文字母都被转化为<strong>小写字母</strong>了。</p><blockquote><p>以前GitHub对中文支持的不好，所以中文标题不能正确识别为锚点，但是现在已经没问题啦！</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>昵称</li></ul><ul><li>别名</li></ul><ul><li>英文名</li></ul><h3 id="多级无序列表"><a href="#多级无序列表" class="headerlink" title="多级无序列表"></a>多级无序列表</h3><ul><li>编程语言<ul><li>脚本语言<ul><li>Python</li></ul></li></ul></li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><h4 id="一般效果"><a href="#一般效果" class="headerlink" title="一般效果"></a>一般效果</h4><p>就是在数字后面加一个点，再加一个空格。不过看起来起来可能不够明显。<br>面向对象的三个基本特征：</p><ol><li>封装</li><li>继承</li><li>多态</li></ol><h4 id="多级有序列表"><a href="#多级有序列表" class="headerlink" title="多级有序列表"></a>多级有序列表</h4><p>和无序列表一样，有序列表也有多级结构：  </p><ol><li>这是一级的有序列表，数字1还是1<ol><li>这是二级的有序列表，阿拉伯数字在显示的时候变成了罗马数字<ol><li>这是三级的有序列表，数字在显示的时候变成了英文字母</li></ol></li></ol></li></ol><h3 id="复选框列表"><a href="#复选框列表" class="headerlink" title="复选框列表"></a>复选框列表</h3><p><code>特定的MD编辑器才支持</code>  </p><ul><li style="list-style: none"><input type="checkbox" checked> 需求分析  </li><li style="list-style: none"><input type="checkbox" checked> 系统设计  </li><li style="list-style: none"><input type="checkbox" checked> 详细设计  </li><li style="list-style: none"><input type="checkbox"> 编码  </li><li style="list-style: none"><input type="checkbox"> 测试  </li><li style="list-style: none"><input type="checkbox"> 交付  </li></ul><p>您可以使用这个功能来标注某个项目各项任务的完成情况。</p><blockquote><p>Tip:</p><blockquote><p>在GitHub的<strong>issue</strong>中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。</p></blockquote></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>表格单元</td><td>表格单元</td><td></td></tr><tr><td>表格单元</td><td>表格单元</td><td></td></tr></tbody></table><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>表格单元</td><td>表格单元</td></tr><tr><td>表格单元</td><td>表格单元</td></tr></tbody></table><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>表格可以指定对齐方式</p><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:center">居中</th><th style="text-align:right">右对齐</th></tr></thead><tbody><tr><td style="text-align:left">col 3 is</td><td style="text-align:center">some wordy text</td><td style="text-align:right">$1600</td></tr><tr><td style="text-align:left">col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td style="text-align:left">zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><h3 id="混合其他语法"><a href="#混合其他语法" class="headerlink" title="混合其他语法"></a>混合其他语法</h3><p>表格单元中的内容可以和其他大多数语法配合使用，如：  </p><h4 id="使用普通文本的删除线，斜体等效果"><a href="#使用普通文本的删除线，斜体等效果" class="headerlink" title="使用普通文本的删除线，斜体等效果"></a>使用普通文本的删除线，斜体等效果</h4><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>Help</td><td><del>Display the</del> help window.</td></tr><tr><td>Close</td><td><em>Closes</em> a window</td></tr></tbody></table><h4 id="表格中嵌入图片（链接）"><a href="#表格中嵌入图片（链接）" class="headerlink" title="表格中嵌入图片（链接）"></a>表格中嵌入图片（链接）</h4><p>其实前面介绍图片显示、图片链接的时候为了清晰就是放在在表格中显示的。</p><table><thead><tr><th>图片</th><th>悬停描述</th></tr></thead><tbody><tr><td><img src="http://www.baidu.com/img/bdlogo.gif" alt="baidu" title="百度logo"></td><td>百度logo</td></tr></tbody></table>]]></content:encoded>
      
      <comments>https://blog.jame-zhang.top/2018/03/10/Markdown%E8%AF%AD%E6%B3%95/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
